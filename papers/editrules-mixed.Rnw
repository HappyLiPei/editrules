%\VignetteIndexEntry{Manipulation of conditional restrictions and error localization with the editrules package}
\documentclass[11pt, fleqn, a4paper]{article}
\usepackage{inconsolata}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{array}
\usepackage[rounded]{syntax}
\usepackage{color, colortbl}
\usepackage{tex/smalltree}
\usepackage{natbib}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}
\usepackage{makeidx}
\usepackage{mySweave}
\makeindex

% shorthand to make '<category>' in syntax diagram
\newcommand{\syncat}{ $\textrm{\sf '}\langle category\rangle\textrm{\sf '}$ }
\newcommand{\notodot}{\odot\kern-0.85em/\:\,}

\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\Lor}{\lor}
\DeclareMathOperator*{\Land}{\land}
\DeclareMathOperator{\ocup}{\cup}
\DeclareMathOperator{\ocap}{\cap}
\newcommand{\rhomap}{\xrightarrow{\rho}}
\newcommand{\rows}{\textrm{rows}}
\newcommand{\columns}{\textrm{columns}}
\newcommand{\ind}{\textrm{\bf ind}}
\newcommand{\true}{\textrm{\sc true} }
\newcommand{\false}{\textrm{\sc false} }

\newtheorem{theorem}{Theorem}[subsection]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newcommand{\theend}{\hfill$\Box$}


\usepackage{float}
 
\floatstyle{boxed}
\newfloat{Rcode}{t!}{rco}
\floatname{Rcode}{{\rm Figure}}
\makeatletter
\renewcommand{\fnum@Rcode}{%
%% make Rcound count and look like a figure.
%    \addtocounter{figure}{1}
    \setcounter{Rcode}{\value{figure}}
    \addtocounter{Rcode}{1}
    \rm Figure~\arabic{Rcode}% <- avoid space before ':'
}
\makeatother


% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}



\hyphenation{
    time-stamp 
    se-pa-ra-te-ly
    ge-ne-ra-li-zed
    e-dit-rules
}

<<echo=false>>=
library(editrules)
@

\title{Manipulation of conditional restrictions and error localization with the
    {\sf editrules} package\\
{\small package version \Sexpr{packageVersion("editrules")}}}
\author{Mark van der Loo and Edwin de Jonge}
\begin{document}
\maketitle
\begin{abstract}
The quality of statistical statements strongly depends on the quality of the
underlying data. As raw data is often inconsistent or incomplete, data editing
often consumes a substantial amount of the resources available for statistical
analyses. Although {\sf R} has many features for analyzing data, the
functionality for data checking and  error localization based on data
restrictions is currently limited.  The {\sf editrules} package is designed to
offer a user-friendly toolbox for edit definition, manipulation, and error
localization based on the generalized paradigm of Fellegi and Holt.  

In this paper we describe new functionality pertaining to conditional
restrictions and restrictions on mixed data. Some of the particularities of
handling such restrictions are discussed in detail. Other additions to the
package include the ability to read edits from free-form text files and faster
error localization in certain cases.

This is the third paper describing functionalities of the {\sf R} {\sf
editrules} package and marks the completion of {\sf editrules} version $3.0$.
The first paper \citep{jonge:2011} describes methods and implementation for
handling numerical data, the second paper \citep{loo:2011b} describes methods
and implementation for handling categorical data. A fourth paper
\citep{jonge:2012} is dedicated to error localization as a mixed integer
problem.

\end{abstract}

\newpage
\tableofcontents

\newpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{sIntroduction}
The quality of raw (survey) data is rarely sufficient to allow for
straightforward statistical analyses. Statisticians often spend a
substantial amount of their time checking and editing datasets prior to the actual
analyses. It has been estimated that National Statistics Offices may devote as
much as 40\% of their resources to data editing activities \citep{waal:2011}.
For reasons of efficiency and reproducibility it is therefore highly desirable
to automate data editing processes. 

In the practice of (official) statistics, data records are often required to
obey various restrictions, including sum rules, positivity demands or other
linear inequalities and categorical restrictions which exclude certain value
combinations.  Such rules are called {\em edit rules} or {\em edits} in short,
and a data record is called {\em inconsistent} when it violates one or more
edits. The goal of data editing is to remove inconsistencies while leaving the 
reported data intact as much as possible.

Data editing is severely complicated by the fact that edit rules
are often interrelated: a variable can occur in more than one restriction, and
a restriction can contain multiple variables. Sets of restrictions on
purely numerical or purely categorical data have been treated in our previous
papers on the {\sf editrules} package \citep{jonge:2011,loo:2011b}. Here, we extend
our treatment to restrictions which are related by conditional statements. An
example of such a statement, connecting a categorical variable ({\em legal form})
with a numerical variable ({\em number of employees}), is 
%
\begin{quote}
If the {\em legal form} (of a business) is self-employed, the {\em number of employees} must be zero.
\end{quote}
\cite{waal:2003} and \cite{waal:2003a} showed that every edit containing
categorical as well as numerical restrictions can be written in such a form.
That is, all restrictions on categorical data occur in the predicate and
numerical restrictions occur in the consequent expression. The formulation is
also general enough to encompass purely numerical or purely categorical rules.
On the other hand, conditional rules connecting two (or more) numerical
restrictions exist as well, as shown by the following example. 
\begin{quote}
If the {\em number of employees} is positive, the {\em amount of salary} payed must be
positive.
\end{quote}

The purpose of this paper is to present version 2.5 of the {\sf R} extension
package {\sf editrules}. This package extends the functionality of the previous
versions by introducing the ability to parse and manipulate conditional
restrictions and to apply them to data. The basic manipulations on edits which
were introduced in the previous versions are extended here to include these
conditional restrictions. These manipulations include, but are not limited to,
redundancy checking, block decomposition, variable elimination and value
substitution.  Error localization, based on the generalized Fellegi-Holt
assumption \cite{fellegi:1976} has been implemented as well.  Error
localization has been implemented using two computational methods. The first
implementation is based on a branch-and-bound algorithm while the second
implementation depends on a mixed-integer formulation of the problem.  This
paper discusses the branch-and-bound algorithm, leaving treatment of the
mixed-integer approach to a separate paper \citep{jonge:2012}.

The rest of this paper is structured as follows. In Section \ref{smixeddata} we
describe which restrictions can be handled by the package, and introduce the
central object for handling conditional restrictions: the {\sf editset} object.
In Section \ref{smanipulation} we provide details on the most important edit
manipulations that the package provides and Section \ref{serrorlocalization} is
devoted to error localization. Examples in {\sf R} code are given throughout to
help new users getting started with this functionality.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mixed data and conditional edits}
\label{smixeddata}
The term ``mixed data'' is used in this paper to indicate data containing both
numerical and categorical data. We do not distinguish between integer and real
numbers here: currently, both are handled as real numbers by {\sf editrules}.
We also do not distinguish between logical and categorical data: under the
hood, {\sf editrules} handles these data types as {\sf character}, although a
user need not consider this when specifying types (see also \cite{loo:2011b}).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\subsection{Reading and writing edits}
\begin{figure}
\begin{Verbatim}[frame=single]
# define category domains
    BOOL <- c(TRUE,FALSE)
    OPTIONS <- letters[1:4]

# (conditional) numerical edits
    x + y == z
    2*u  + 0.5*v == 3*w
    w >= 0
    if ( x > 0 ) y > 0
    if ( x > y ) z < 10
    x >= 0
    y >= 0
    z >= 0

# categorical and mixed data edits
    A %in% OPTIONS
    B %in% OPTIONS
    C %in% BOOL
    D %in% letters[5:8]
    if ( A %in% c('a','b') ) y > 0
    if ( A == 'c' ) B %in% letters[1:3]
    if ( !C == TRUE) D %in% c('e','f')
\end{Verbatim}
\vspace{-0.8cm}
\caption{Example of a free-form text file defining numerical, categorical and conditional 
edits. The edits can be read into {\sf R} with the {\sf editfile} function.}
\label{fig:editfile}
\end{figure}
%


As described in our previous papers on {\sf editrules}, edits can be read from
the commandline in {\sf character} form, or from a {\sf data.frame}. However,
it is now also possible to read edits from {\sf R} {\sf expression} vectors or,
most conveniently, from a free-form text file.

As an example, Figure \ref{fig:editfile} shows the contents of an example text file
that is included with the package. Note that category domains may be defined
separately from the edits themselves. This is convenient for domains which are
reused over several variables or for large domains that need to be read from file. 
Numerical and categorical edits can be submitted as they would for objects
of class {\sf editmatrix} or {\sf editarray} respectively, while conditional
edits must follow the following syntax diagram.
%
\begin{syntdiag}
if ( 
\begin{rep}
    \begin{stack}
        <linear inequality>\\
        <set expression>
    \end{stack}\\
\begin{stack}   "&"\\"&&"\end{stack}
\end{rep}
)
\begin{rep}
    \begin{stack}
        <linear inequality>\\
        <set expression>
    \end{stack}\\
\begin{stack}   "|"\\"||"\end{stack}
\end{rep}
\end{syntdiag}
Here, \verb+&+ and \verb+&&+ and \verb+|+ and \verb+||+ are synonyms. The
symbol $\langle\textrm{\em set expression}\rangle$ is an expression indicating
set membership for categorical values, for example {\tt A \%in\% c("a","b")}. See
\cite{loo:2011b} for a syntax diagram of possible set expressions.  Comments
are allowed as well, and will be ignored by the parser. 

The example file of Figure \ref{fig:editfile} is included with the package. It can be
read as follows\footnote{The built-in {\sf system.file} command to locates
the example file independent of the package's installation directory.}.
<<>>=
myfile <- system.file("script/edits/myedits.txt",
    package="editrules")
(E <- editfile(myfile))
@
\label{code:editfile}
Here, {\sf E} is an object of class {\sf editset}. An {\sf editset} is a
generalisation of objects of class {\sf editarray} and {\sf edimatrix},
in that it can contain numerical, categorical and conditional edits.

When printed to screen, the data model for categorical variables, as well as
the textual representation of the edits are shown. For convenience, edits are
named according to their type.  Pure numerical edits are numbered with prefix
{\sf num}, pure categorical with prefix {\sf cat} and conditional edits are
prefixed with {\sf mix}. 


Edits can be selected with the bracket operator, using integer or logical indices,
for example:
<<>>=
E[c(7,10),]
@
By default, the full data model is retained when selecting a subset of edits.
The {\sf reduce} function can be used to remove variables not occurring in any edit from an
{\sf editset} object.

The function {\sf editfile} has an optional {\sf type} argument, allowing for
extracting only the numerical ({\sf type="num"}), categorical ({\sf
type="cat"}) or conditional edits ({\sf type="mix"}) from the text file.  When
{\sf type="num"} or {\sf type="cat"}, an {\sf editmatrix} or {\sf editarray} is
returned respectively. Using these more specialized objects yields some
performance enhancement for common operations such as value substitution and
variable elimination. Under the hood, {\sf editfile} parses the file, looks for
assignments (by {\sf <-} or {\sf =}) and evaluates them in a separate {\sf R}
{\sf environment}. Next, the edits are generated within that environment.

To export edits, the most convenient way is to use either {\sf as.character} to
convert an {\sf editset} to text or {\sf as.data.frame} to convert it to a
2-column {\sf data.frame}. One can then use {\sf R}'s standard I/O
functionality to store edits as a structured text file, or use one of the
database interfaces to send edits to a database. See Table \ref{tabcoercion}
for an overview of coercion options.


\begin{table}
\begin{threeparttable}
\caption{Functions for reading and coercing (conditional) edits.}
\label{tabcoercion}
\begin{tabular}{lp{0.7\textwidth}}
\hline
Function        & Description\\
\hline
{\sf editfile}     & read from free-form textfile\\
{\sf editset}      & read from {\sf character} or {\sf expression} vector\\
{\sf as.character} & convert editset to {\sf character} vector\\
{\sf as.data.frame}& convert editset to two-column {\sf data.frame}\\ 
\hline
\end{tabular}
\end{threeparttable}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Visualizing and disentangling edits}
\label{ss:disentangling}
As stated in the introduction, the fact that edits are entangled by shared variables
severely complicates data editing: changing the value of a variable to solve an edit
violation may cause the violation of another edit.

To make data editing more tractable, it is desired to break entangled sets of
edits into smaller independent subproblems as much as possible. Table
\ref{tab:separators} gives an overview of edit separation functions available
in the {\sf editrules} package. 

As an example, consider the dependency graph of the edits introduced in Figure
\ref{fig:editfile}. The graph can be generated by issuing the command
<<eval=false>>=
plot(E)
@
and is depicted in Figure \ref{fig:graph}. Internally, the graph is generated
by calling {\sf contains} on {\sf E}, which returns a logical matrix that
indicates which edit contains which variables. Next, this matrix is converted
to an {\sf igraph} object and plotted with the {\sf igraph0} package
\citep{csardi:2006}. The plot methods for {\sf editset}, {\sf editmatrix} and
{\sf editarray} have several options for coloring violated edits or erroneous
variables. Refer to the built-in documentation of the package for an extensive
overview and examples.


The dependency graph clearly shows that our example set can be split into three
unrelated blocks. These blocks (corresponding to columns of data) can be
treated separately if statistical correlations between the variables can be
ignored. The higher-level error localization function that will be discussed in
section \ref{ss:errorlocalization}, detects and exploits this block structure, so
users need not concern themselves with it directly. However, to facilitate edit
rule investigation and maintenance, the lower-level {\sf blocks} function is
exported to user space. This function returns a {\sf list} of the independent
{\sf editsets}, as illustrated by the following example.
<<>>=
sapply(blocks(E),nedits)
@
Here, {\sf nedits} counts the number of edits in an editset. Clearly, the three
independent blocks with 8, 3 and 1 edits (Figure \ref{fig:graph}) have been
found.

The largest cluster of edits in Figure \ref{fig:graph} connects numerical
variables with categorical variables. Operations such as variable elimination
are difficult to implement for such edit sets. However, it is possible to split
up such a set further by working out what happens when we assume statements in
the premise or consequent to be {\sc true} or {\sc false}. 

% according to Yihui, God kills a little kitten here :'(
\setkeys{Gin}{width=0.7\textwidth}
\begin{figure}
\centering
<<fig=true, echo=false>>=
set.seed(3)
par(oma=c(0,0,0,0),mar=c(0,0,0,0))
plot(E)
@
\caption{Dependency graph of edits defined in Figure \ref{fig:editfile}. The
squares represent edit rules, and the circles represent variables. An edge
indicates that a variable occurs in an edit.  }
\label{fig:graph}
\label{fig:graph}
\end{figure}
Consider again the edits on page \pageref{code:editfile}.  As an example,
assume that $x>0$ in \verb"mix9". We then know that $y>0$ must hold. This means
that \verb"num5" becomes redundant and \verb"mix11" reduces to $y>0$ and
becomes therefore redundant.  On the other hand, when we assume $x\leq0$, then
\verb"mix9" can be dropped, since the value of $y$ has become unimportant for
that edit.  Combined with \verb"num4", assuming that $x\leq0$ this means that
$x=0$.  These two assumptions exclude each other (they cannot both be valid)
and yield two different edit sets. If we continue making assumptions for the
numerical statements in conditional edits recursively and work out their
consequences, we get a list of {\em conditional} {\sf editsets} where for each
{\sf editset}, the dependencies between categorical and numerical edits have
been severed.

The function {\sf disjunct} implements this procedure. It speeds up computation
by detecting whenever contradictory assumptions have been made. The function
returns a {\sf list} of conditional {\sf editsets} (optionally, they can be
returned as an {\sf R} {\sf environment}). The conditions pertaining to each
{\sf editset} can be retrieved using the {\sf condition} function.  Figure
\ref{fig:disjunct} shows the dependency graphs of the four conditional {\sf
editsets} resulting after calling {\sf disjunct}. The conditional {\sf
editsets} form an equivalent representation of the original set and have the
advantage that operations such as variable elimination (and therefore error
localization) are can be performed separately for each set.  The downside is
that for large, strongly connected edit sets, separating them into disjunct
sets can be a computationally daunting task, growing exponentially in the
number of edits. For this reason, we have implemented an error localization
method not that does not require variable elimination. This method, which is
based on a mixed-integer formulation of the problem will be discussed in a
separate paper \citep{jonge:2012}.

In Figure \ref{fig:disjunct} the dependency graphs of the conditional editsets
in {\sf disjunct(E)} are shown. The restrictions in the title are conditions
under which all restrictions in the graph below them must be obeyed. Note that
the names of edits cannot be compared across the subplots. These names are
generated automatically and are unrelated to content of the edit, other than
stating the type of variables to which the edit pertains. In the original
editset there are three conditional edits containing numerical restrictions,
namely
<<>>=
E[9:11,]
@
Four different numerical restrictions occur in these edits, so we can make
$2^4$ assumptions about their truth values. However, some assumptions will
contradict each other. For example, the demands $x\leq0$, $y>0$ and $y<x$
cannot all be true at the same time. The result is that only four out of
sixteen possible edit sets are feasible, as shown in Figure \ref{fig:disjunct}.

Finally, we note that the utility function {\sf separate} performs both the
block decomposition based on variable occurrence and calls, when appropriate,
the {\sf disjunct} function on conditional edits. The results are simplified as
much as possible and returned in a {\sf list}.

<<echo=false>>=
v <- disjunct(E)
@

\begin{figure}
\setkeys{Gin}{width=0.9\textwidth}
<<fig=true,echo=false>>=
v <- disjunct(E)
par(oma=c(0,0,0,0),mar=c(0,0,1.5,0),mfrow=c(2,2),pty='m')
for ( i in 1:length(v) ){
    set.seed(1)
    plot(
        v[[i]],
        main=paste(as.character(editrules:::condition(v[[i]])),collapse=', ')
    )
}
@
\caption{Dependency graphs of the conditional {\sf editsets}
generated from the edits of Figure \ref{fig:editfile}. There are no paths from
numerical variables ($x$, $y$, $z$, $u$, $v$, $w$) to categorical 
variables ($A$, $B$, $C$, $D$) anymore. The titles of the subplots indicate
the predicates for each {\sf editset}. Edits with the same name contain the
same variables but not necessarily the same condition on those variables across
subplots.
}
\label{fig:disjunct}
\end{figure}







\begin{table}[t]
\caption{Edit separation functions. Each function accepts an {\sf editset} as input.}
\label{tab:separators}
\begin{tabular}{lp{0.8\textwidth}}
\hline
Function & Description\\
\hline
{\sf contains}  & Detects which edit contains which variable\\
{\sf plot}      & Plot the dependency graph\\
{\sf blocks}    & Splits an {\sf editset} in independent edits not sharing any variables\\
{\sf disjunct}  & Splits an {\sf editset} in disjunct sets, not containing mixed edits\\
{\sf condition} & Returns the {\sf editmatrix} holding the conditions for an {\sf editset} generated by {\sf disjunct}\\
{\sf separate}  & Uses {\sf blocks}, simplifies the results, and calls {\sf disjunct} on the remaining {\sf editset}s\\
\hline
\end{tabular}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Edit checking, obvious redundancy and obvious infeasibility}
\label{ss:checking}
Data can be checked against edits in an editset with the {\sf violatedEdits}
function. This function accepts an {\sf editset} and a {\sf data.frame} and
returns a logical array (of class {\sf violatedEdits}) where each row and
column indicates which record violates what edit. A {\sf summary} and {\sf
plot} method is available for {\sf violatedEdits} objects so users can get a
quick overview of edit violation frequencies. Internally, the {\sf
violatedEdits} method for editsets works by coercing the edits to logical {\sf
character} expression and using {\sf R}'s evaluation functionality to parse and
evaluate these expressions in the context of the {\sf data.frame}. 

An edit in an {\sf editset} is obviously redundant when it is the duplicate of
another edit or when it has an easily recognizable form such as $0 < 1$. Such
redundancies may arise after edit manipulations (value substitution, variable
elimination).  The {\sf isObviouslyRedundant} method for {\sf editset} returns
a logical vector indicating which edit in an editset is redundant (\true) or
not ({\sc false}). If the {\sf editset} was separated in independent
conditional {\sf editsets} by {\sf disjunct}, a list of boolean vectors is returned.
For a detailed description of detecting obvious redundancies in numerical or
categorical edits, we refer to \cite{jonge:2011} and \cite{loo:2011b}.

An edit in an {\sf editset} is obviously infeasible when it contains an easily
recognizable self-contradicting edit, such as $0>1$. The function {\sf
isObviouslyInfeasible} returns \true for editsets containing one or more
obvious contradictions in numerical or categorical edits. Note that
when {\sf isObviouslyInfeasible} returns {\sc false}, this does not
guarantee that the set of edits is consistent. Contradictions may still
be implied by the edits. Finding out whether a set of edits is satisfiable
can be far more computationally intensive. We will return to this problem
in Section \ref{ss:elimination}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Manipulation of conditional edits}
\label{smanipulation}
The two basic operations on any set of restrictions, either numerical,
categorical, or conditional, are value substitution and variable elimination.
Methods for the pure numerical and pure categorical situations are fairly
straightforward and have been implemented in the {\sf editrules} package
before. Operations on conditional edits require a bit more care, which will be
detailed in the next two subsections.

\subsection{Value substitution}
\label{sssubstitution}
Assigning a value to a variable occurring in an {\sf editset} can be done with
the {\sf substValue} function. For example, substituting $x=10$ in the
edits of Figure \ref{fig:editfile} gives 
<<>>=
(F <- substValue(E,'x',10))
@ 
Compare this result with the edits displayed on page \pageref{code:editfile}.
Observe that the original edit, stating $\textrm{\sf if } x > 0 \textrm{ \sf then } y>0$
has disappeared from the mixed edits, and that in stead the numerical edit
$y>0$ has appeared, as is to be expected.
<<>>=
substValue(F,'y',20)
@



%
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Variable elimination and satisfiability}
\label{ss:elimination}
Variable elimination is the mechanism by which edits, logically implied by a
set of (user-defined) edits, are derived.  Variable elimination amounts to
deriving all implicit edit rules from a set of edits which do not contain the
eliminated variable anymore.  For an {\sf editset} object, it is executed by
first separating the edits in disjunct sets as described in Section
\ref{ss:editlist}.  Next, since in each element of the resulting {\sf editlist}
the dummy {\sf editmatrix} $E_{\sf mixnum}$ is empty, variable elimination
takes place on each $E_{\sf num}$ or $E_{\sf mixcat}$ of the {\sf editlist} for
numerical or categorical variables respectively. The methods used for variable
elimination in an {\sf editmatrix} are described in \cite{jonge:2011} while the
methods for variable elimination from an {\sf editarray} are described in
\cite{loo:2012}. Consequently, the result of an {\sf eliminate} operation is an
object of class {\sf editlist}. 

As an example, consider again the set of edits of Eqs.~\eqref{eq:edits}
and~\eqref{eq:editlist}. In Figure~\ref{figprojections}, the valid regions are
indicated as grey areas.  Geometrically, eliminating variable $y$ amounts to a
projection along the $y$-axis.  Figure \ref{figprojections}  shows the result
of projecting out the $y$ variable in bold lines.  Algebraically, we need to
apply Fourier-Motzkin elimination to the edits in the consequents of
Eq.~\eqref{eq:editlist} to obtain
(remember that $\veebar$ stands for exclusive or)
\begin{displaymath}
\left(
\textrm{\sf if } x\geq0 \textrm{ \sf then }  \varnothing
\right)
\veebar
\left(
\textrm{\sf if } x < 0 \textrm{ \sf then } x < -2\right).
\end{displaymath}
The first term says that when $x\geq 0$, there are no further restrictions.
The second element says that when $x<0$, $x$ must actually be smaller than $-2$. Figure
\ref{fig:elimination} shows how the results are displayed in {\sf R} by {\sf editrules}.


\setcounter{Rcode}{\value{figure}}
\begin{Rcode}[t!]
<<>>=
G <- editset(expression(
    if ( x >= 0 ) y >= 0,
    if ( x >= 0 ) x <= y,
    if ( x < 0 ) y < 0,
    if ( x < 0 ) x - y < -2
))
eliminate(G,"y")
@
\caption{Eliminating a variable from an object of class {\sf editset} results in an {\sf editlist}.}
\label{fig:elimination}
\end{Rcode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Error localization in mixed data}
\label{serrorlocalization}

\subsection{A branch-and-bound algorithm}
The error localization problem consists of finding the least (weighted) number
of fields in a record that can be adapted or imputed, such that no edits are
violated anymore. For purely categorical or purely numerical edit sets, the
feasible space of records is convex, and each solution can be determined by a
sequence of variable substitutions or eliminations.  For objects of class {\sf
editmatrix} and class {\sf editarray} a branch-and-bound algorithm generating
such sequences has been implemented before \citep{jonge:2011,loo:2011b}.  When
conditional edits are present, as in the example of Figure
\ref{figprojections}, solving an error localization problem is equivalent to
solving it for each convex subregion separately and selecting the lowest-weight
solution afterwards. 

In {\sf editrules}, error localization with conditional edits (in an {\sf
editset}) starts by separating the edits into blocks and disjunct sets
using the {\sf separate} function discussed in Section \ref{ss:editlist}.
Separate blocks share no variables and are treated independently. Blocks
consisting of {\sf editmatrix} or {\sf editarray} objects are treated as
described in the references mentioned before. Blocks consisting of {\sf
editlists} have to be treated differently. Remember that an {\sf editlist} is a set
of disjunct {\sf editsets}, each describing a convex region of the record domain. An
{\sf editlist} enters a similar branch-and-bound algorithm as {\sf
editmatrices} and -{\sf arrays}, with the difference is that each
elimination and substitution step is performed separately on each element of an
{\sf editlist}.  Whenever one of the elements of an {\sf editlist} becomes
infeasible it is removed from the list. When no feasible regions are left and
not all variables have been treated, a bound condition is hit and the branch is
pruned. If all variables have been treated, and no inconsistencies were
encountered, a (list of) solutions is found. When all solutions are
found, the lowest weight solution can be selected.

The process is accelerated by detecting whenever the current weight of partial
solutions equals the weight of previous solutions. At that point, all remaining
values are substituted to check whether the branch can lead to an actual
solution. If so, the solution is stored; if not, a bound condition is hit. 


\subsection{Acceleration by data model checking}
Observe that the number of nodes of the branch-and-bound tree grows as $2^n$,
with $n$ the number of variables (and hence the depth of the tree).  In some
cases the tree depth can be reduced by noting that variables which violate
simple, single-variable range edits will always be part of the error
localization solution. These single-variable edits are easily checked (in a
vectorized manner) and variables violating such edits can be removed from the
multivariate localization problem. 

The solution to an error localization problem for a number of records in a
dataset with $n$ variables can be represented as matrix ${\bf M}$ where
$M_{ij}>0$ if variable $j$ in record $i$ must be changed and $0$ otherwise.  To
construct such a matrix, we assume a set of single-variable edits, and
proceed as follows.  Define ${\bf V}$ as the matrix where $V_{ik}=1$ if
record $i$ violates edit $k$ and $0$ otherwise.  To account for missing values,
we also set $V_{ik}=1$ when edit violation cannot be established because the
value of the variable to which range edit $k$ pertains is missing.  Also,
define ${\bf C}$ as the matrix with $C_{kj}=1$ if edit $k$ contains
variable $j$ and $0$ otherwise. The matrix ${\bf M}$ is then given by
\begin{equation}
{\bf M} = {\bf V}{\bf C}.
\end{equation} 

In {\sf editrules}, this operation has been implemented in the function {\sf checkDatamodel}.
This function returns an object of class {\sf errorLocation}, but does not yield a full solution,
as demonstrated by the example of Figure \ref{R:checkdatamodel}.

\addtocounter{figure}{1}
\begin{Rcode}
<<>>=
E <- editmatrix(expression(
    x > 0,
    x + y == 2
))
(dat <- data.frame(x=c(-1,2),y=c(3,0)))
checkDatamodel(E,dat)$adapt
localizeErrors(E,dat)$adapt
@
\caption{An example of {\sf checkDatamodel}, which only detects violation of range edits,
while {\sf localizeErrors} finds the full solution. The result of both functions is an
object of class {\sf errorLocation} which contains (amongst other things) for each record
which variables should be adapted. Clearly, in the first record $(x=-1,y=3)$ both $x$ and $y$
must be adapted. However, {\sf checkDatamodel} only checks the one-dimensional edits, {\em i.c.}
the edit $x>0$.
}
\label{R:checkdatamodel}
\end{Rcode}

\subsection{Error localization with {\sf localizeErrors} and {\sf errorLocalizer}} 
\label{ss:errorlocalization}
The interfaces of {\sf localizeErrors} and {\sf
errorLocalizer} for objects of class {\sf editset} are similar to those of {\sf
editmatrix} and {\sf editarray}.  They will therefore not be described
extensively here, instead we refer the reader to \cite{jonge:2011} and
\cite{loo:2011b}. In short, function {\sf localizeErrors} accepts an {\sf
editset} and a {\sf data.frame} along with some optional arguments and returns
an object of class {\sf errorLocation}. The function {\sf errorLocalizer}
returns a {\sf backtracker} object that allows fine control over the
branch-and-bound search algorithm.

New to version {\sf 2.5} of the package is that {\sf localizeErrors} uses {\sf
checkDatamodel} to identify fields that fail range edits prior to entering the
branch-and-bound algorithm.  We note that for large, highly entangled edit
sets, especially those with many conditional edits, the branch-and-bound
algorithm may take a long time to complete. For this reason a second backend
algorithm has been implemented, that uses a mixed-integer programming
formulation of the localization problem. It can be accessed by providing the
optional parameter {\sf method="mip"} to {\sf localizeErrors}. For a comparison
between the two algorithms refer to \cite{jonge:2012}.

\section{Conclusions}
We described new functionality of the {\sf editrules} package, pertaining to
conditional restrictions and mixed data edits. All existing edit manipulation
functions have been overloaded to handle the new {\sf editset} object.

Several new edit manipulation features have been added, most notably the
possibility to split sets of edits in disjunct sets that do not contain any
mixed data edits anymore. Also, the branch-and-bound error localization methods
have been accelerated by taking care of range edit violations prior to
multivariate error localization.

Future work on the package may include the extension to {\em soft edits}, where
not only the violation of an edit is weighed in the process of error
localization but also the {\em amount} of violation can be taken into account.


\label{sconclusions}

\clearpage
\bibliographystyle{chicago}
\bibliography{editrules}

\clearpage
\addcontentsline{toc}{section}{Index}
\printindex



\end{document}


