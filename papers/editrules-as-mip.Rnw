%\VignetteIndexEntry{Error localization for numerical and categorical edits as a mixed integer problem}
\documentclass[11pt, fleqn, a4paper]{article}
%\usepackage{inconsolata}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{array}
%\usepackage[rounded]{syntax}
%\usepackage{color, colortbl}
\usepackage{natbib}
%\usepackage[noend]{algpseudocode}
%\usepackage{algorithm}
%\renewcommand{\algorithmicrequire}{\textbf{Input:}}
%\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}
\usepackage{makeidx}
\makeindex

\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\Lor}{\lor}
\DeclareMathOperator*{\Land}{\land}
\DeclareMathOperator{\ocup}{\cup}
\DeclareMathOperator{\ocap}{\cap}

\newcommand{\packageversion}{{\sf 2.5}}
\newcommand{\code}[1]{\textsf{#1}}
\newcommand{\R}{\code{R}} %% call as \R{} to avoid extra spaces.

\usepackage{float} 
\floatstyle{boxed}
\newfloat{Rcode}{t!}{rco}
\floatname{Rcode}{{\rm Figure}}
\makeatletter
\renewcommand{\fnum@Rcode}{%
%% make Rcound count and look like a figure.
%    \addtocounter{figure}{1}
    \setcounter{Rcode}{\value{figure}}
    \addtocounter{Rcode}{1}
    \rm Figure~\arabic{Rcode}% <- avoid space before ':'
}
\makeatother


% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}


\hyphenation{
    time-stamp 
    se-pa-ra-te-ly
    ge-ne-ra-li-zed
    e-dit-rules
}

<<init, echo=FALSE, results='hide', message=FALSE>>=
library(editrules)
#library(xtable)
@

\title{Error localization as a mixed integer problem with the {\tt editrules} package\\
{\small package version \Sexpr{packageVersion("editrules")}}}
\author{Edwin de Jonge and Mark van der Loo}
\begin{document}
\maketitle
\begin{abstract}
R package {\sf editrules} offers a mixed integer programming implementation for 
localizing erronous fields. We describe the mip formulation for numerical, categorical 
localizing erroneous fields. We describe the mip formulation for numerical, categorical 
and mixed edits and their implementation. A benchmark is given between the branch 
and bound and mip that are both available in {\sf editrules}. 
\end{abstract}

\newpage
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
Analyses of real data are often hindered by occurrences of incomplete or
inconsistent raw data records.  The process of locating and correcting such
errors is referred to as {\em data editing}, and it has been estimated that
National Statistics Institutes spend up to 40\% of their resources on this
process \citep{waal:2011}. For this reason, considerable attention is paid to
the development of data editing methods that can be automated. Since data are
often required to obey many interrelated consistency rules, data
editing can be too complex to perform manually. \citet{winkler:1999} mentions
practical cases where records have to obey 250, 300 or even 750 internal
consistency rules.  Although the {\sf R} statistical environment has numerous
facilities for analyzing categorical data [See {\em e.g.} \citet{husson:2010}],
the options for error localization and record correction are currently limited.

The {\sf R} package {\sf editrules} was
developed to help closing the gap between raw data retrieval and data analysis
with {\sf R}.  The main purpose of the {\sf editrules} package is to provide a
rules to data, and to localize erroneous fields in data based on the
generalized principle of \cite{fellegi:1976}.  The package does not offer
functionality for data correction. However, it does facilitate the
identification of the set of solutions for an error correction problem. 
For a detailed description we refer to \cite{jonge:2011}, \cite{loo:2011b} and {}.

{\sf editrules} offers a fairly complete toolbox to work with numerical and 
categorical edits. It contains a flexible object for localizing errors, which 
can be adapted by the user of {\sf editrules} based on a branch and bound
algorithm \citep{waal:2011}. However, for the time to solve the error 
localization problem with a branch and bound algorithm grows exponentially 
with the number of (incorrect) variables. Many surveys have hundreds of variables, 
which results in (very) long processing times for records with many errors. 

This paper describes the error localization problem for numerical, categorical 
and mixed edits as a mixed integer problem and its implementation in 
{\sf editrules}. Error localization implemented as a mixed integer programming 
results in a fast procedure, which is typically much faster than the branch 
and bound method also available in {\sf editrules}.

We start with a brief description of mixed integer programming and its 
application to the error localization problem.  
In section \ref{sec:numdataerror} we describe a mip formulation for numerical 
records. Section \ref{sec:catdataerror} describes the mip formulation for categorical records. Restriction on both numerical and categorical can also be implemented using mip. We describe the mip implementation of so called mixed edits in \ref{sec:mixdataerror}.
We end with a discussion on the implementation in {\sf editrules}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Error localization as a mixed integer problem}
\label{sec:mipproblem}

Mixed integer programming is a special case of linear programming. Linear 
programming maximizes a linear objective function, which is subject to linear
equality and linear inequality constraints. More formally: 
\begin{eqnarray}
   \textrm{Maximize } {\bf c}^T {\bf x} \label{eq:mipmax}\\
   A {\bf x} \leq {\bf b} \\
   \textrm{with } {\bf x} \geq 0 \label{eq:mippos}
\end{eqnarray}
where ${\bf x}$ is the vector of (numerical) variables to be optimized, ${\bf c}$ is a vector of weights, ${\bf b}$ is a vector of upper bounds and $A$ is a coefficient matrix for the constraints. In mixed integer programming (mip) ${\bf x}$ is a mixture of continuous and integer variables.

Mixed integer programming is well understood and there are several software 
packages that implement efficient solvers for linear and mixed integer problems. 
If your problem can be formulated as a mip problem, mip software can be used to
solve the original problem.
In {\sf editrules} we use \ref{lpSolveAPI:2011} to formulate and solve our mip problems. 

Most mip software allows for a broader (but equivalent) formulation of the 
mip problem.  (\ref{eq:mipmax}) can be written as  a minimization problem 
 by changing the sign of ${\bf}c^T$,  $A$ can include equality constraints 
by replacing each equality with two inequality constraints and ${\bf x}$ can be negative
by adding so-called slack variables. In our formuluation of error localization
as a mip problem we make use of this broader definition.

In this paper we formulate Felligi Holt error localization \citep{fellegi:1976} 
for numerical, categorical and mixed constraints as mip problems. 
This principle minimizes the (weighted) number of variables that must be 
changed to obey a set of constraints. The formulations for error localization
for the three types are different but all have the same parts:

\begin{itemize}
  \item[] An objective function that minimizes the (weighted) number of adaptions
  in the form of ${\bf w}^T {\bf \Delta}$, with ${\bf w}$ the vector of weights
  and ${\bf \Delta}$ a vector of binary adaptation variables. 
  If $\Delta_i = 1$, value $r_i^0$ of record ${\bf r}$ is considered erroneous.
  This objective function is the same for all three types.
  \item[a)] A numerical description ${\bf x}$ of record ${\bf r}$ that includes 
  binary adaptation variables ${\bf \Delta}$ and possibly auxiliary variables. 
  \item[b)] The hard constraints (edits) that each record ${\bf r}$ {\bf must} obey 
  formulated in the form ${\bf A}^H {\bf x} \leq {\bf b}^H$.
  \item[c)] The reported values ${\bf r}^0$ that record ${\bf r}$ {\bf should} obey 
  formulated as constraints ${\bf A}^0 {\bf x} \leq {\bf x}^0$. These assure
  that if $r_i \neq r_i^0$ then $\Delta_i = 1$.
\end{itemize}

In the next sections we will describe the mip formulations for the numerical, 
categorical and mixed edits and show their implementation in {\sf editrules}.

\subsection{Further reading}
An overview of several mixed integer formulations for error localization can 
be found in \citep{waal:2011} p. 75.
Mixed integer programming (convex programming etc.).
List of mip software.
Internally the package \cite{lpSolveAPI:2011} is used to 
solve the resulting mixed integer program.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Numerical data errors}
\label{sec:numdataerror}
\code{editrules} allows for the following numerical constraints (see \ref{jonge:2011}).
Suppose a numerical record $\bf r$  with reported values $({r^0_1,\dots,r^0_m)}$ has the following linear constraints:
\begin{equation}
\label{eq:edit}
A {\bf r \odot b} \textrm{ with }\odot\in\{<,\leq,=\}^n,
\end{equation}

Note that this formulation is almost identical to the constraint part of linear optimization problems. 

\subsection{Mip formulation}

\begin{itemize}
  \item[a)]
  The mapping from record ${\bf r}$ to $\bf x$ is easy:
  \begin{equation}
  {\bf x} = (r_1, \ldots, r_m, \Delta_1, \ldots, \Delta_m)
  \end{equation}
  with $\Delta_i \in \{0,1\}$\\
  
  \item[b)]
  Writing the constraints $A$ of equation \ref{eq:edit} into ${\bf A}^H$  
  is also straightforward, with the exception of strict inequalities.
  We rewrite strict inequalities by subtracting a sufficiently small $\epsilon$ from $b_j$.
  \begin{equation}
  \sum_{i=1}^m a_{ji} r_i < b_j \implies \sum_{i=1}^m a_{ji} r_i \leq b_j - \epsilon
  \end{equation}
  
  Note that for reasons we give later you should avoid writing strict inequalities
  as much as possible.
  
  \item[c)]
  The constraints ${\bf A}^0$ for the reported values can be written as:
  \begin{eqnarray}
                           r_i & \leq    & r^0_i + M \Delta_i \label{eq:numsoft1} \\
            r^0_i - M \Delta_i & \leq    & r_i  \label{eq:numsoft2}
  \end{eqnarray}
  with $M$ sufficiently large and $i = \{1,\ldots,m\}$. \\
  
  It can easily be checked that if $\Delta_i = 0$ then $r_i = r^0_i$ and 
  if $\Delta_i = 1$ then $r_i$ can take any value 
  between $r^0_i - M$ and  $r^0_i + M$. 
  Since the objective function tries to minimize $w^T \Delta_i$, 
  the mip solver will try to keep each variable $r_i$ at its reported value $r^0_i$.
\end{itemize}

This makes the mip formulation for error localization in numerical edits complete.

\subsection{Implementation}
In {\sf editrules} we use an {\sf editmatrix} object to store numerical data 
constraints. This object is described extensively in {\cite{jonge:2011}}
As shown in a previous paper (\cite{jonge:2011}).
<<nummatrix example>>=
(E <- editmatrix("y >= x"))
@
The example \code{E} shows that \code{editmatrix} recognizes the constraint: it has been 
rewritten in standard normalized format.

<<echo=FALSE>>=
em <- writeELAsMip(E, x=c(x=10, y=0), weight=c(x=1,y=2))
@

<<tidy=FALSE, eval=FALSE>>=
em <- writeELAsMip(E, x=c(x=10, y=0), weight=c(x=1,y=2))
@

{\sf editrules} has the 
function {\sf localizeErrors} which by default uses a branch and bound 
algorithm. We extended this function with a parameter {\tt method}, that can be 
used to select the {\tt "bb"} or {\tt "mip"} method. 
For many purposes specifying {\tt "mip"} will increase
the speed without noticable changes in the output.
<<num example>>=
E <- editmatrix("x <= y")
dat <- data.frame(x=c(10, 2), y=c(1,2))
weight <- data.frame(x=c(2,1), y=c(1,1))

bb <- localizeErrors(E, dat, weight=weight)
mip <- localizeErrors(E, dat, weight=weight, method="mip")

bb$adapt
mip$adapt
@

Internally {\sf localizeErrors} uses for each record {\sf errorLocalizer.mip}.
<<num mip>>=
E <- editmatrix("x <= y")
r <- c(x=10, y=1)
weight <- c(x=2, y=1)
el <- editrules:::errorLocalizer.mip(E, r, weight=weight)
str(el)
@



<<>>=
# write errorlocalization as mip
mip <- editrules:::writeELAsMip(E, r, weight=weight)
print(mip$E, textOnly=TRUE)
mip$objfn[mip$objfn > 0]
@

\subsection{Numerical subtleties}

The mip formulation for numerical constraints depends on two constants $M$ and
$\epsilon$. These constants end up in the coefficient matrix of the mip solver.
Mathematically the size of these coefficients does not matter. Computationally 
however it does: if coefficient $a_{ij} \ll a_{kl}$ then the solution
may become numerical unstable, since the ratio of the two may be 
indistinguishable from zero to the mip solver. 

In {\sf editrules} by default $M = 10^7$ and $\epsilon = 10^{-3}$ is used. This will 
be sufficient for most purposes, since numerical values and coefficient of the constraints 
in most cases will be in this range. If not, you should rescale some of your variables and constraints to make it so.

From the lpsolve manual \citep{lpsolveman:2012}:

\begin{quote}
The chance for numerical instability and rounding errors is considerably 
larger when the input data contains both large and small numbers. 
So to improve stability, one must try to work with numbers that are somewhat 
in the same range. Ideally in the neighborhood of 1.\\

You should realize, that you the user are probably in a better position to 
scale the problem than any computer algorithm. 
\end{quote}

\section{Categorical data errors}


\label{sec:catdataerror}
A categorical record $\bf v$  with reported values $({v^0_1,\dots,v^0_m)}$ has the following $n$ constraints:
\begin{equation}e_j = 
  \begin{array}{rl}
    \label{eq:catedit}
    \mbox{{\bf if }} & v_i \in F_{i,j} \mbox{ for }i = 1, \ldots, m \\
    \mbox{ {\bf then}} & \mbox{FALSE}
  \end{array}
\end{equation}
with $F_{i,j} \subseteq D_i$ where $i$ is the number of variables, $D_i$ is the possible set of categories $\{c_{i,1}, \ldots, c_{i,l_i}\}$ for $v_i$ and $j = 1 \ldots n$ the number of edits.

Remarkable about categorical edits is their negative formulation in 
literature (e.g. \ref{}): if a condition is true than the edit is violated. This is in contrast with numerical edits, which state rules that the record must obey. To translate categorical edits into mip we need a possitive reformulation, since mip requires constraints 
that must hold.

Equation (\ref{eq:catedit}) can be written in the following form:
\begin{eqnarray}
     e_j  & = & \lnot \bigwedge_{i=1}^m v_i \in F_{i,j} = \bigvee_{i=1}^m\lnot (v_i \in {F_{i,j}}) \\
          & = &  \bigvee_{i=1}^m v_i \not\in {F_{i,j}} = \bigvee_{i=1}^m v_i \in T_{i,j} \label{eq:catpos}
\end{eqnarray}
with $T_{i,j} = D_i \setminus F_{i,j}$. 
This means that edit $e^j$ is satisfied if at least one $v_i \in T_{i,j}$. 

\subsection{Mip formulation}
\begin{itemize}
  \item[a)]
  Recall from section \ref{sec:mipproblem} that in a mip problem ${\bf x}$ is a 
  numerical vector. We therefore encode each $v_i$ in $l_i$ binary dummy variables
  $$
  v_i = (d_{i,1}, \ldots, d_{i,l_i})
  $$
  with
  \begin{equation}
    d_{i,k} = \left\{ 
    \begin{array}{ll}
           1 & \mbox{if $v_i = c_{i,k}$}\\
           0 & \mbox{if $v_i \neq c_{i,k}$}
    \end{array} \right. 
  \end{equation}
  
  The numerical representation of $\bf{v}$, a record of $m$ categorical variables 
  can then be written as:
  \begin{equation}
    {\bf x} = (d_{1,1}\ldots d_{1,n_1}, \ldots, d_{m, 1}, \ldots, d_{m, l_m}, 
    \Delta_1, \ldots, \Delta_m)
  \end{equation}
  
  \item[b)]
  Constraint matrix ${\bf A}$ for categorical edits is composed out of two parts.
  First the fact that each $v_i$ can only have one categorical value:
  \begin{equation}
     \sum^{n_i}_{k=1} d_{i,k} = 1
  \end{equation}
  for $i$ is $(1, \ldots, m)$
  
  Second the categorical constraints of equation \ref{eq:catpos}. They can now be written as:
  
  \begin{equation} \label{eq:tmip}
    \sum^m_{i=1} \left(\sum^{l_i}_{k=1} t_{i,j,k} \cdot d_{i,k}\right) 
    \geq 1
  \end{equation}
  
  \begin{equation} \label{eq:aijk}
    \mbox{with }
    t_{i,j,k} = \left\{ 
    \begin{array}{ll}
           0 & \mbox{if } c_{i,k} \not\in T_{i,j}\\
           1 & \mbox{if } c_{i,k} \in T_{i,j}
    \end{array} \right. 
  \end{equation}
  If one of the $c_{i,k} \in T^j_i$ then the edits is valid.\\
  
  
  \item[c)]
  The constraints ${\bf A}^0$ can be written as:
  
  \begin{equation}
     d_{i,k^0_i}  =  1 - \Delta_i 
  \end{equation}
  where $k^0_i$ denotes the reported value $v^0_i$
  It can be easily checked that if $\Delta_i = 0$ $d_{i,k^0} = 1$, 
  meaning that the reported value 
  $v^0_i$ is assumed correct. 
  If $\Delta_i = 1$, $d_{i,k^0_i} = 0$, meaning that $v_i$ must have a different 
  value. Since mip minimizes the objective function it will try to keep the reported 
  values $v^0_i$
\end{itemize}
This makes the mip formulation for categorical edits complete.

\subsection{Implementation}
\subsection{The {\sf cateditmatrix} object}
To create a mip formulation for the categorical error localization problem,
{\sf editrules} uses internally the {\sf cateditmatrix} object. {\sf
cateditmatrix} is an {\sf editmatrix} object, which is described in
\cite{jonge:2011}, but it "remembers" that it is categorical. 
%
\begin{Rcode}
<<tidy=FALSE>>=
E <- editrules:::cateditmatrix( 
       expression( gender %in% c("male", "female")
                 , if (pregnant) gender == "female"
                 )
                  )
as.data.frame(E)
getAb(E)
@
\caption{Using the {\sf cateditmatrix} object}
\label{R:cateditmatrix}
\end{Rcode}
Figure \ref{R:cateditmatrix} shows an example for the use of {\sf cateditmatrix}. It also shows that categorical edits can be written in the form of a linear constraint to be used in an mixed integer problem solver. 
{\sf cateditmatrix} can coerce an {\sf editarray}. This method can be called explicitly by a user, but it 
it will be called implicitly in {\sf localizeErrors} using {\tt method="mip"}.
An example is shown in figure \ref{R:localizeCat}

% checkDatamodel is niet overloaded voor cateditmatrix. Moeten we dit doen, aangezien cateditmatrix (nog) niet 'public' is.
\begin{Rcode}
<<keep.source=TRUE>>=
#dat <- data.frame(gender="male", pregnant=TRUE)
#localizeErrors(E,dat, method="mip")
@
\caption{Using {\sf localizeErrors} method with categorical data}
\label{R:localizeCat}
\end{Rcode}

\begin{figure}
<<tidy=FALSE>>=
E <- editarray(c(
    "gender %in% c('male','female')",
    "pregnant %in% c('yes','no')",
    "if (gender == 'male') pregnant == 'no'"
    )
)
E
@
\caption{This is a caption}
\end{figure}

\section{Mixed data errors}
\subsection{Mip formulation}
\subsection{Implementation}

<<tidy=FALSE>>=
E <- editset(expression(
  married %in% c(TRUE, FALSE),
  if (married==TRUE) age >= 17
  ))
editrules:::writeELAsMip(E, x=c(age=9, married=TRUE))
errorLocalizer.mip(E, x=c(age=9, married=TRUE))
localizeErrors(E, dat=data.frame(age=9, married=TRUE))
@


\section{Conclusion}
\bibliographystyle{chicago}
\bibliography{editrules}

\end{document}
