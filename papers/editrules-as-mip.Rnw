%\VignetteIndexEntry{Error localization for numerical and categorical edits as a mixed integer problem}
\documentclass[11pt, fleqn, a4paper]{article}
\usepackage{inconsolata}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{array}
\usepackage[rounded]{syntax}
\usepackage{color, colortbl}
\usepackage{tex/smalltree}
\usepackage{natbib}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}
\usepackage{makeidx}
%\usepackage{mySweave}
\makeindex

% shorthand to make '<category>' in syntax diagram
\newcommand{\syncat}{ $\textrm{\sf '}\langle category\rangle\textrm{\sf '}$ }
\newcommand{\notodot}{\odot\kern-0.85em/\:\,}

\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\Lor}{\lor}
\DeclareMathOperator*{\Land}{\land}
\DeclareMathOperator{\ocup}{\cup}
\DeclareMathOperator{\ocap}{\cap}
\newcommand{\rhomap}{\xrightarrow{\rho}}
\newcommand{\rows}{\textrm{rows}}
\newcommand{\columns}{\textrm{columns}}
\newcommand{\ind}{\textrm{\bf ind}}
\newcommand{\true}{\textrm{\sc true} }
\newcommand{\false}{\textrm{\sc false} }

\newtheorem{theorem}{Theorem}[subsection]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newcommand{\theend}{\hfill$\Box$}

\newcommand{\packageversion}{{\sf 2.5}}

\usepackage{float}
 
\floatstyle{boxed}
\newfloat{Rcode}{t!}{rco}
\floatname{Rcode}{{\rm Figure}}
\makeatletter
\renewcommand{\fnum@Rcode}{%
%% make Rcound count and look like a figure.
%    \addtocounter{figure}{1}
    \setcounter{Rcode}{\value{figure}}
    \addtocounter{Rcode}{1}
    \rm Figure~\arabic{Rcode}% <- avoid space before ':'
}
\makeatother


% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}



\hyphenation{
    time-stamp 
    se-pa-ra-te-ly
    ge-ne-ra-li-zed
    e-dit-rules
}

<<init, echo=FALSE>>=
library(editrules)
@

\title{Error localization as a mixed integer problem with the {\tt editrules} package\\
{\small package version \Sexpr{packageVersion("editrules")}}}
\author{Edwin de Jonge and Mark van der Loo}
\begin{document}
\maketitle
\begin{abstract}
TO DO
\end{abstract}

\newpage
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
Analyses of real data are often hindered by occurrences of incomplete or
inconsistent raw data records.  The process of locating and correcting such
errors is referred to as {\em data editing}, and it has been estimated that
National Statistics Institutes spend up to 40\% of their resources on this
process \citep{waal:2011}. For this reason, considerable attention is paid to
the development of data editing methods that can be automated. Since data are
often required to obey many interrelated consistency rules, data
editing can be too complex to perform manually. \citet{winkler:1999} mentions
practical cases where records have to obey 250, 300 or even 750 internal
consistency rules.  Although the {\sf R} statistical environment has numerous
facilities for analyzing categorical data [See {\em e.g.} \citet{husson:2010}],
the options for error localization and record correction are currently limited.

The {\sf R} package {\sf editrules} was
developed to help closing the gap between raw data retrieval and data analysis
with {\sf R}.  The main purpose of the {\sf editrules} package is to provide a
user-friendly environment for handling data restriction rules, to apply those
rules to data, and to localize erroneous fields in data based on the
generalized principle of \cite{fellegi:1976}.  The package does not offer
functionality for data correction. However, it does facilitate the
identification of the set of solutions for an error correction problem. 
For a detailed description we refer to \cite{jonge:2011}, \cite{loo:2011b} and {}.

{\sf editrules} offers a fairly complete toolbox to work with numerical and 
categorical edits. It contains a flexible object for localizing errors, which 
can be adapted by the user of {\sf editrules} based on a branch and bound
algorithm \citep{waal:2011}. However, for the time to solve the error 
localization problem with a branch and bound algorithm grows exponentially 
with the number of (incorrect) variables. Many surveys have hundreds of variables, 
which results in (very) long processing times for records with many errors. 

This paper describes the error localization problem for numerical, categorical and mixed edits as a mixed integer problem and its implementation in {\sf editrules}. Error localization implemented as a mixed integer programming results in a fast procedure, which is typically much faster than the branch and bound method also available in {\sf editrules}.

We start with a brief description of mixed integer programming and its application to the error localization problem.  
In section \ref{sec:numdataerror} we describe a mip formulation for numerical records. Section ref describes the mip formulation for categorical records. We end with a discussion on the implementation in {\sf editrules}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Error localization as a mixed integer problem}
\label{sec:mipproblem}

Mixed integer programming is a special case of linear programming. Linear 
programming maximizes a linear objective function, which is subject to linear
equality and linear inequality constraints. More formally: 
\begin{eqnarray}
\label{eq:mip}
   \textrm{Maximize } {\bf c}^T {\bf x} \\
   A {\bf x} \leq {\bf b} \\
   \textrm{with } {\bf x} \geq 0
\end{eqnarray}
where ${\bf x}$ is the vector of (numerical) variables to be optimized, ${\bf c}$ is a vector of weights, ${\bf b}$ is a vector of upper bounds and $A$ is a coefficient matrix for the constraints. In mixed integer programming (mip) ${\bf x}$ is a mixture of continious and integer variables.

Mixed integer programming is well understood (books?) and there are several sofware packages (citations) that implement efficient solvers for linear and mixed integer problems. If you can formulate your problem as a mip problem, this software can be used to solve the original problem.
In {\sf editrules} we use \ref{lpSolveAPI:2011} to formulate and solve our mip problems. Note that most mip software allows the \ref{eq:mip} to be formulated as a minimization problem where ${\bf}x$ can be negative. They also allow for equality constraints. These are all are simple extensions of \ref{eq:mip}.

In this paper we formulate Felligi Holt error localization \citep{fellegi:1976} for numerical, categorical and mixed constraints as MIP problems. This error localization principle minimizes the (weigthed) number of variables that we should change given the current constraints.
The formulations for error localization for numerical, categorical and mixed edits all have the same parts.
\begin{itemize}
  \item A numerical description ${\bf x}$ of record ${\bf r}$ including adaptations ${\bf \Delta}$ and dummy variables. 
  \item The constraints (edits) that each record ${\bf r}$ must obey formulated in the form ${\bf A} {\bf x} \leq {\bf b}$
  \item The reported values ${\bf r}^0$ formulated as soft constraints for ${\bf r}$ in the form ${\bf A}^0 {\bf x} = {\bf x}^0$
  \item The (binary) adaption variables $\Delta_i$ that are constrained to 1 if $r_i \neq r^0_i$ in the form ${\bf A}^\Delta {\bf x} \leq {\bf b}^\Delta$  
  \item The objective function that minimizes the (weighted) number of adaptions in the form of ${\bf w}^T {\bf \Delta}$
\end{itemize}

\subsection{Further reading}
An overview of several mixed integer formulations for error localization can be found in \citep{waal:2011} p. 75.
Mixed integer programming (convex programming etc.)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Numerical data errors}
\label{sec:numdataerror}
{\sf editrules} allows for the following numerical constraints (see \ref{jonge:2011}).
A numerical record $\bf r$  with reported values $({r^0_1,\dots,r^0_m)}$ has the following linear constraints:
\begin{equation}
\label{eq:edit}
A {\bf r \odot b} \textrm{ with }\odot\in\{<,\leq,=\}^n,
\end{equation}

\subsection{Mip formulation}

The mapping from record ${\bf r}$ to $\bf x$ is relatively easy:
\begin{equation}
{\bf x} = (r_1, \ldots, r_m, \Delta_1, \ldots, \Delta_m, \delta^{+}_1, \ldots, \delta^{+}_m,\delta^{-}_1, \ldots, \delta^{-}_m)
\end{equation}
with $\delta^{+}_i \geq 0 $, $\delta^{-}_i \geq 0$ and $\Delta_i \in \{0,1\}$.\\


Writing the constraints $A$ of \ref{eq:edit} is also straightforward, with the exception of strict inequalities.
We rewrite strict inequalities by subtracting a sufficiently small $\epsilon$
\begin{equation}
a_{ij} r_i < b_j \iff a_{ij} x_i \leq b_j - \epsilon
\end{equation}

The soft constraint for the reported values can be written as:
\begin{eqnarray}
                         x_i & =    & r^0_i + \delta^{+}_i - \delta^{-}_i \\
  \delta^{+}_i + \delta^{-}_i& \leq & M \Delta_i
\end{eqnarray}
with $M$ sufficiently large and $i = \{1,\ldots,m\}$. \\

It can easily be checked that if $\Delta_i = 0$ then $x_i = r^0_i$ and 
if $\Delta_i = 1$ then $x_i$ can take any value 
between $r^0_i - M$ and  $r^0_i + M$.

This makes the mip formulation for error localization in numerical edits complete.

\subsection{Implementation in editrules}

As shown in a previous paper (\cite{jonge:2011}), {\sf editrules} has the function {\sf localizeErrors} 
which by default uses a branch and bound algorithm. This can be changed to mip
by supplying the parameter {\sf method="mip"}. For many purposes this will increase
the speed without noticable changes in the output.
<<num example>>=
E <- editmatrix("x <= y")
dat <- data.frame(x=c(10, 2), y=c(1,2))
weight <- data.frame(x=c(2,1), y=c(1,1))
le <- localizeErrors(E, dat, weight=weight, method="mip")
le$status
@

Internally {\sf localizeErrors} uses for each record {\sf errorLocalizer.mip}.
<<num mip>>=
E <- editmatrix("x <= y")
r <- c(x=10, y=1)
weight <- c(x=2, y=1)
el <- editrules:::errorLocalizer.mip(E, r, weight=weight)
str(el)

@

<<>>=
# write errorlocalization as mip
mip <- editrules:::writeELAsMip(E, r, weight=weight)
print(mip$E, textOnly=TRUE)
mip$objfn
@




\subsection{Numerical subtleties}

 

\subsection{Boundaries}
The extended edit set derived in (\ref{eq:nummip}) depends on the boundaries $\rm l_i$ and 
$\rm u_i$. Mathematically the size of these coefficients does not matter. Computationally however their
size is important. If any $|{\rm u_i - c_i}| \gg |a_j|$ or $|{\rm l_i - c_i}| \gg |a_j|$ the resulting mixed integer program may become numerical
unstable. From the lpsolve manual \citep{lpsolveman:2012}:

\begin{quote}
The chance for numerical instability and rounding errors is considerably larger when the input data contains both large and small numbers. So to improve stability, one must try to work with numbers that are somewhat in the same range. Ideally in the neighbourhood of 1.\\

You should realize, that you the user are probably in a better position to scale the problem than any computer algorithm. 
\end{quote}

\subsection{Implementation in {\sf editrules}}
{\sf editrules} contains the function {\sf localizeErrors} which can be used to localize errors in a {\tt data.frame}. It default implemention using a branch and bound algorithm is described in detail in \citep{jonge:2011}. It accepts an {\sf editmatrix} and a {\sf
data.frame}, and returns an object of class {\sf errorLocation}. An {\sf
errorLocation} object contains the locations of errors for each record in the
{\sf data.frame} as well as logging information, solution weights and
degeneracy. 

We extended this function with a parameter {\tt method}, that can be used to select the {\tt "localizer"} or {\tt "mip"} method. If the method {\tt "mip"} is specified, {\sf editrules} internally creates for each 
record an extended {\sf editmatrix} {\tt E} that contains the conditional boundary conditions as defined 
in (\ref{eq:nummip}). Internally the package \cite{lpSolveAPI:2011} is used to solve the resulting mixed integer program.
%


Figure \ref{RlocalizeErrors} shows an example of localizing errors using mip. 

%
\begin{Rcode}
<<keep.source=TRUE>>=
E <- editmatrix(c(
    "x + y == z",
    "x > 0",
    "y > 0",
    "z > 0"))

dat <- data.frame(
    x = c(1,-1,1),
    y = c(-1,1,1),
    z = c(2,0,2))

# localize all errors in the data using mip
localizeErrors(E,dat, method="mip")
@
\caption{Localizing errors in a data.frame using {\tt method="mip"}}
\label{RlocalizeErrors}
\end{Rcode}

The default boundary conditions used in {\tt localizeErrors} use ${\rm u_i} = 1000 \cdot x^0_i$ and ${\rm l_i} = -1000 \cdot x^0_i$.

\section{Categorical data errors}

\label{sec:catdataerror}
A categorical record $\bf v$  with reported values $({v^0_1,\dots,v^0_m)}$ has the following $n$ constraints:
\begin{equation}e^i = 
  \begin{array}{rl}
    \label{eq:catedit}
    \mbox{{\bf if }} & v_j \in F^i_j \mbox{ for }j = 1, \ldots, m \\
    \mbox{ {\bf then}} & \mbox{FALSE}
  \end{array}
\end{equation}
with $F^i_j \subseteq D_j$ where $D_j$ is the possible set of categories $\{1, \ldots, k\}$ for each $v_j$ and $i = 1 \ldots n$ the number of edits.

It can easily be checked with {\sf editrules} if $\bf v$ violates any of these constraints. If this is the
case, the task is to find the minimal (weighted) number of adjustments to the reported values such that it
complies to the edits. Internally {\sf editrules} uses an {\sf editarray} object which is described in 
detail in \cite{loo:2011b}. In this paper we use a different, but equivalent, representation to allow for 
an easy conversion to a mixed integer program: {\sf cateditmatrix}.

A record of $m$ categorical variables can be written as an element
of the cartesian product space $D$:
\begin{equation}
  \label{eq:Domain}
  D = D_1\times D_2\times\cdots\times D_m,
\end{equation}
where each $D_j$ is the set of possible categories for variable $j$.

The number of categories for variable $j$ is labeled $d_j$ while the
total number of categories is labeled $d$, given by
\begin{equation}
  d=\sum_{j=1}^n d_j
\end{equation}
Categorical record $\bf v$ can be written in this space as
\begin{equation}
  \begin{array}{rcl}
    {\bf \check{v}} & = & \oplus^m_{j=1} (\check{v}_{j1}, \ldots, \check{v}_{j{d_j}}) \\
                    & = & (\check{v}_{1 1}, \cdots, \check{v}_{1 {d_1}},
                          \cdots, \check{v}_{m 1}, \cdots,     \check{v}_{m {d_m}})
  \end{array}
\end{equation}

\begin{equation}
  \mbox{with }
  \check{v}_{jk} 
  =  \left\{ 
  \begin{array}{ll}
         0 & \mbox{if } v_j \not= k \\
         1 & \mbox{if } v_j = k
  \end{array} \right.
\end{equation}

Equation (\ref{eq:catedit}) can be written in the following form:
\begin{eqnarray}
     e^i  & = & \lnot \bigwedge_{j=1}^m v_j \in F^i_j = \bigvee_{j=1}^m\lnot (v_j \in {F^i_j}) \\
          & = &  \bigvee_{j=1}^m v_j \not\in {F^i_j} = \bigvee_{j=1}^m v_j \in T^i_j
\end{eqnarray}
with $T^i_j = D_j \setminus F^i_j$. 
This means that edit $e^i$ is satisfied if at least one $v_j \in T^i_j$. $e^i$ can therefore be written as:

\begin{equation} \label{eq:tmip}
  \sum^m_{j=1} \left(\sum^{d_j}_{k=1} t^i_{jk} \cdot \check{v}_{jk}\right) \geq 1
\end{equation}

\begin{equation} \label{eq:aijk}
  \mbox{with }
  t^i_{jk} = \left\{ 
  \begin{array}{ll}
         0 & \mbox{if } k \not\in T^i_j\\
         1 & \mbox{if } k \in T^i_j
  \end{array} \right. 
\end{equation}
These edits are (usually) valid for all records of a data set. Note that equation (\ref{eq:catmip}) is in 
a form to be used in a mixed integer program where $\check{v}_{jk}$ are integer variables.

For each $v_j$ its categories should exclude each other, so the following constraint must hold:
\begin{equation}
   \left(\sum^{d_j}_{k=1} \check{v}_{jk}\right) \leq 1
\end{equation}

We introduce for each $v_j$ a binary variable $\Delta_j \in {0,1}$:
\begin{equation} \label{eq:catdelta}
  \Delta_j = \left\{ 
  \begin{array}{ll}
         0 & \mbox{if $v_j = v^0_j$}\\
         1 & \mbox{if $v_j \neq v^0_j$}.
  \end{array} \right. 
\end{equation}

where $v^0_j$ is the reported value for $v_i$. We now add the following edit to the edit set:
\begin{equation}
   \check{v}_{jk^0_j}  =  1 - \Delta_j \mbox{ with } k^0_j = v^0_j
\end{equation}
It can be easily checked that if $\Delta_j = 0$ $\check{v}_{jk^0_j} = 1$, meaning that the reported value 
$v^0_j$ is assumed correct. If $\Delta_j = 1$, $\check{v}_{jk^0_j} = 0$, meaning that $v_j$ should have a different value.

The categorical error localization problem now can be written as:

{\textrm Minimize} $\sum^m_{j=1} {\rm w_j}\Delta_j$, with:
\begin{equation}
\label{eq:catmip}
\begin{array}{rcrcl}
  \sum^m_{j=1} \left(\sum^{d_j}_{k=1} t^1_{jk} \cdot \check{v}_{jk}\right)&& &\geq& 1 \\
  \ldots                 &&                  &\ldots& \ldots  \\
  \sum^m_{j=1} \left(\sum^{d_j}_{k=1} t^n_{jk} \cdot \check{v}_{jk}\right)&& &\geq& 1 \\
    \sum^{d_1}_{k=1} \check{v}_{1k} && & \leq & 1 \\
    \check{v}_{1k^0_1} & +    & \Delta_1 & =    & 1 \\
    \ldots  & & \ldots          &       & \ldots \\
    \sum^{d_m}_{k=1} \check{v}_{mk} && & \leq & 1 \\
    \check{v}_{mk^0_m} & + & \Delta_m & =    & 1 \\
\end{array}
\end{equation}

Note that parts of equation (\ref{eq:tmip}) can be written in a negated form:
\begin{equation} \label{eq:fmip}
  \mbox{ if } T^i_j \neq \emptyset \mbox{ then } \sum^{d_j}_{k=1} t^i_{jk} \cdot \check{v}_{jk}  = 1 - \left(\sum^{d_j}_{k=1} f^i_{jk} \cdot \check{v}_{jk} \right) 
\end{equation}

\begin{equation} \label{eq:aijk}
  \mbox{with }
  f^i_{jk} = \left\{ 
  \begin{array}{ll}
         0 & \mbox{if } k \not\in F^i_j\\
         1 & \mbox{if } k \in F^i_j
  \end{array} \right. 
\end{equation}

\subsection{The {\sf cateditmatrix} object}
To create a mip formulation for the categorical error localization problem,
{\sf editrules} uses internally the {\sf cateditmatrix} object. {\sf
cateditmatrix} is an {\sf editmatrix} object, which is described in
\cite{jonge:2011}, but it "remembers" that it is categorical. 
%
\begin{Rcode}
<<keep.source=TRUE>>=
E <- editrules:::cateditmatrix( 
       expression( gender %in% c("male", "female")
                 , if (pregnant) gender == "female"
                 )
                  )
as.data.frame(E)
getAb(E)
@
\caption{Using the {\sf cateditmatrix} object}
\label{R:cateditmatrix}
\end{Rcode}
Figure \ref{R:cateditmatrix} shows an example for the use of {\sf cateditmatrix}. It also shows that categorical edits can be written in the form of a linear constraint to be used in an mixed integer problem solver. 
{\sf cateditmatrix} can coerce an {\sf editarray}. This method can be called explicitly by a user, but it 
it will be called implicitly in {\sf localizeErrors} using {\tt method="mip"}.
An example is shown in figure \ref{R:localizeCat}

% checkDatamodel is niet overloaded voor cateditmatrix. Moeten we dit doen, aangezien cateditmatrix (nog) niet 'public' is.
\begin{Rcode}
<<keep.source=TRUE>>=
#dat <- data.frame(gender="male", pregnant=TRUE)
#localizeErrors(E,dat, method="mip")
@
\caption{Using {\sf localizeErrors} method with categorical data}
\label{R:localizeCat}
\end{Rcode}

\begin{figure}
<<tidy=FALSE>>=
E <- editarray(c(
    "gender %in% c('male','female')",
    "pregnant %in% c('yes','no')",
    "if (gender == 'male') pregnant == 'no'"
    )
)
E
@
\caption{This is a caption}
\end{figure}

\section{localizeErrors}

\section{Discussion}

\subsection{Comparison to {\tt backtracker}}
errorLocalizer is more complete, offers a more complete tool box for finding an optimal solution.
It can also find more equivalent solutions, which is not possible or difficult with MIP solvers.

\bibliographystyle{chicago}
\bibliography{editrules}

\end{document}
