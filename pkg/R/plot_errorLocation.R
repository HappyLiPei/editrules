#' plot errorLocation object
#' 
#'
#' Gives an overview of results generated by \code{link{localizeErrors}}
#'
#' The plot shows the error frequency for variables and observations, a density plot of the
#' time it took to find the solutions and a bar plot of the number of degenerate records found.
#' Variables with zero errors are not shown in the bar chart. The plot with the frequency of errors
#' per record is shown with a logarithmic y-scale if the number of unique error counts exceeds 30.
#' The plot with the number of degenerate solutions is shown on a logarithmic x-axis if the unique number
#' of degeneracies exceeds 30. Note that degeneracy of 1 can indicate that a record has no errors or has errors,
#' and only one solution to the error localization problem was found (for example, when the record is completely empty).
#' 
#' 
#' @method plot errorLocation
#' @param x errorLocation object
#' @param nvar Number of variables to show in 'errors per variable plot'. Only the top-nvar are shown. 
#'      By default the top-20 variables with the most errors are shown.
#' @param ... other arguments that will be transferred to \code{barplot}
#' @export
plot.errorLocation <- function(x, nvar=min(20,ncol(x$adapt)), ...){
  oldpar <- par(mfcol=c(2,2))
  N <- nrow(x$adapt)
  # plot errors per variable
  vf <- colSums(x$adapt)
  # break variable names at 5th char.
  names(vf) <-  gsub('(.{5})','\\1\n',names(vf))

  varfreq <- sort(vf[vf>0]/N,decreasing=TRUE)
  barplot( varfreq[1:min(nvar,length(varfreq))]
         , main = "Errors per variable"
         , xlab = "Frequency"
         , horiz = TRUE
         , las = 1
         , ...
         )

   # plot errors per observation  
   cnt <- table(rowSums(x$adapt))
   ns <- as.numeric(names(cnt))
   br <- integer(max(ns)+1)
   br[ns+1] <- cnt/N
   names(br) <- 0:max(ns) 
  barplot( br
         , main = "Errors per observation"
         , xlab = "Frequency"
         , ylab = "Number of errors"
         , horiz = TRUE
         , log=ifelse(length(br)>30,'y','')
         , ...
         )

    # plot duration density
    eps <- sqrt(.Machine$double.eps)
    du <- density(log(x$status$user+eps))
    de <- density(log(x$status$elapsed+eps))
    du$F <- cumsum(du$y)*(du$x[2]-du$x[1])
    de$F <- cumsum(de$y)*(de$x[2]-de$x[1])
    du$x  <- exp(du$x)
    de$x  <- exp(de$x)
    par(mar=c(5,4,4,5)+.1)
    plot(de$x,de$y,
        log='x',
        type='l',
        lwd=2,
        col='black',
        xlab='duration [seconds]',
        ylab='density',
        main='Duration of error localization'
    )
    lines(du,lwd=2,col='blue')
    par(new=TRUE)

    plot(de$x,de$F,
        col='black',
        lwd=2,
        type='l',
        lty=2,
        log='x',
        xaxt="n",
        yaxt="n",
        xlab="",
        ylab="")
    axis(4)
    mtext("cumulative",side=4,line=3)
    lines(du$x,du$F,lwd=2,lty=2,col='blue')
    grid()
    # default horiz abline used by plot.density crosses image border.
    lines(c(min(de$x),max(de$x)),c(0,0),col='gray',lwd=0.1)
    legend('topright',
        legend= c(
            paste('elapsed (total: ',secToHuman(sum(x$status$elapsed)),')', sep=''),
            paste('user (total: ',secToHuman(sum(x$status$user))   ,')', sep=''),
        sub=paste(sum(x$status$maxDurationExceeded),'exeeded max. duration')
        ),
        col=c('black','blue','white'),
        lwd=2,
        bg='white'    
    )

  # plot solutions degeneracy
  tb <- table(x$status$degeneracy)
  br <- integer(max(x$status$degeneracy))
  br[as.numeric(names(tb))] <- tb
  
  barplot(br,
    log=ifelse(length(br)>30,'x',''),
    names.arg=1:max(x$status$degeneracy),
    main='Number of degenerate solutions',
    xlab='degeneracy',
    ylab='count')
  par(oldpar)
}


# translate time in seconds to human-readable format
secToHuman <- function(x){
    if ( x < 1 )    return(paste(round(1000*x),'ms'))
    if ( x < 60 )   return(paste(round(x,2),'s'))
    if ( x < 3600 ) return(paste(round(x/60,2),'min'))
    if ( x < 24*3600 ) return(paste(round(x/3600,2),'hours'))
    if ( x < 24*3600*365 ) return(paste(round(x/3600/34,2),'days'))
    paste(round(x/24/3600/365,2),'years')
}



