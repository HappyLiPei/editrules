%\VignetteIndexEntry{Manipulation of conditional restrictions and error localization with the editrules package}
\documentclass[11pt, fleqn, a4paper]{article}
\usepackage{inconsolata}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{array}
\usepackage[rounded]{syntax}
\usepackage{color, colortbl}
\usepackage{tex/smalltree}
\usepackage{natbib}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}
\usepackage{makeidx}
\usepackage{mySweave}
\makeindex

% shorthand to make '<category>' in syntax diagram
\newcommand{\syncat}{ $\textrm{\sf '}\langle category\rangle\textrm{\sf '}$ }
\newcommand{\notodot}{\odot\kern-0.85em/\:\,}

\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\Lor}{\lor}
\DeclareMathOperator*{\Land}{\land}
\DeclareMathOperator{\ocup}{\cup}
\DeclareMathOperator{\ocap}{\cap}
\newcommand{\rhomap}{\xrightarrow{\rho}}
\newcommand{\rows}{\textrm{rows}}
\newcommand{\columns}{\textrm{columns}}
\newcommand{\ind}{\textrm{\bf ind}}
\newcommand{\true}{\textrm{\sc true} }
\newcommand{\false}{\textrm{\sc false} }

\newtheorem{theorem}{Theorem}[subsection]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newcommand{\theend}{\hfill$\Box$}


\usepackage{float}
 
\floatstyle{boxed}
\newfloat{Rcode}{t!}{rco}
\floatname{Rcode}{{\rm Figure}}
\makeatletter
\renewcommand{\fnum@Rcode}{%
%% make Rcound count and look like a figure.
    \setcounter{Rcode}{\value{figure}}
    \addtocounter{Rcode}{1}
    \rm Figure~\arabic{Rcode}% <- avoid space before ':'
}
\makeatother


% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}



\hyphenation{
    time-stamp 
    se-pa-ra-te-ly
    ge-ne-ra-li-zed
    e-dit-rules
}

<<echo=false>>=
library(editrules)
@

\title{Manipulation of conditional restrictions and error localization with the
    {\sf editrules} package\\
{\small package version \Sexpr{packageVersion("editrules")}}}
\author{Mark van der Loo and Edwin de Jonge}
\begin{document}
\maketitle
\begin{abstract}
The quality of statistical statements strongly depends on the quality of the
underlying data. As raw data is often inconsistent or incomplete, data editing
often consumes a substantial amount of the resources available for statistical
analyses. Although {\sf R} has many features for analyzing data, the
functionality for data checking and  error localization based on data
restrictions is currently limited.  The {\sf editrules} package is designed to
offer a user-friendly toolbox for edit definition, manipulation, and error
localization based on the generalized paradigm of Fellegi and Holt.  

In this paper we describe new functionality pertaining to conditional
restrictions and restrictions on mixed data. Some of the particularities of
handling such restrictions are discussed in some detail. Other enhancements
include the ability to read edits from free-form text files and faster
error localization in certain cases.

This is the third paper describing functionalities of the {\sf R} {\sf
editrules} package and marks the completion of {\sf editrules} version $3.0$.
The first paper \citep{jonge:2011} describes methods and implementation for
handling numerical data, the second paper \citep{loo:2011b} describes methods
and implementation for handling categorical data. A fourth paper
\citep{jonge:2012} is dedicated to error localization as a mixed integer
problem.

%{\em For package version 3.0-0, this vignette is a near literal 
%    transcript of \cite{loo:2011b}. Please refer to that paper
%    when referencing categorical data handling with {\sf editrules}.
%    This vignette will be updated with the package if necessary.}
\end{abstract}

\newpage
\tableofcontents
\listofalgorithms

\newpage


\section{Introduction}
\label{sIntroduction}
The quality of raw (survey) data is only rarely sufficient to allow for
straightforward statistical analyses. Statisticians often have to spend a
substantial amount of time checking and editing datasets prior to the actual
analyses. It has been estimated that National Statistics Offices may devote as
much as 40\% of their resources to data editing activities \cite{waal:2011}.
For reasons of efficiency and reproducibility it is therefore highly desirable
to automate data editing processes. 

In the practice of (official) statistics, data records are often required to
obey various restrictions, including sum rules, positivity demands or other
linear inequalities and categorical restrictions which exclude certain value
combinations.  Such rules are called {\em edit rules} or {\em edits} in short,
and a data record is called {\em inconsistent} when it violates one or more
edits. One goal of data editing is to adapt reported values such that no
edits are violated anymore.

Data editing is severely complicated by the fact that that edit rules
are often interrelated: a variable can occur in more than one restriction, and
a restriction can contain multiple variables. Sets of restrictions on
purely numerical or purely categorical data have been treated in our previous
papers on the {\sf editrules} package \citep{jonge:2011,loo:2011b}. Here, we extend
our treatment to restrictions which are related by conditional statements. An
example of such a statement, connecting a categorical variable {\em legal form}
with a numerical variable ({\em number of employees}), is 
%
\begin{quote}
If the legal form (of a business) is self-employed, the number of employees must be zero.
\end{quote}
\cite{waal:2003} and \cite{waal:2003a} showed that every edit containing
categorical as well as numerical data can be written in such a form. That is,
all restrictions on categorical data occur in the predicate and numerical
restrictions occur in the consequent expression. The formulation is general
enough to encompass purely numerical restrictions (the predicate becomes {\sc
true}) as well as purely categorical rules (the consequent becomes {\sc
false}). However, rules connecting numerical restrictions are not uncommon, as
shown by the following example. 
\begin{quote}
If the number of employees is positive, the amount of salary payed must be
positive.
\end{quote}

The purpose of this paper is to present version 3.0 of the {\sf R} extension
package {\sf editrules}. This package extends the functionality of the previous
versions by introducing the ability to parse and manipulate conditional
restrictions and to apply them to data. The package can now handle restrictions
where numerical restrictions occur in the predicate as well as in the
consequent of conditional restrictions.  The basic manipulations on edits which
were introduced in the previous versions for numerical or categorical data are
extended here to include conditional restrictions. These manipulations include,
but are not limited to, redundancy checking, block decomposition, variable
elimination and value substitution.  Error localization for data under
conditional edits based the generalized Fellegi-Holt assumption
\cite{fellegi:1976} is provided as well. Error localization has been
implemented using two computational methods. The first based on a
branch-and-bound algorithm and the second on a mixed-integer formulation of the
problem.  This paper discusses the branch-and-bound algorithm, leaving
treatment of the mixed-integer approach to a separate paper \citep{jonge:2012}.

The rest of this paper is structured as follows. In Section \ref{smixeddata} we
describe which restrictions can be handled by the package, and introduce the
central object for handling conditional restrictions: the {\sf editset} object.
In Section \ref{smanipulation} we provide details on the most important edit
manipulations that the package provides and Section \ref{serrorlocalization} is
devoted to error localization. Examples in {\sf R} code are given throughout to
help new users getting started with this functionality.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mixed data and conditional edits}
\label{smixeddata}
The term ``mixed data'' is used here to indicate data containing both numerical
and categorical data. We do not distinguish between integer and real numbers
here: currently, both are handled as real numbers by {\sf editrules}. We also do not
distinguish between logical and categorical data: under the hood, {\sf editrules}
handles these data types as {\sf character}, although a user need not consider
this when specifying types (see also \cite{loo:2011b}).

\subsection{The {\sf editset} object}
A record in a mixed dataset can be described as an element of the domain
\begin{equation}
R = D_1\times D_2\times\cdots\times D_p\times \mathbb{R}^{q}.
\end{equation}
Here, $p$ and $q$ are positive integers that denote the number of categorical
and numerical variables respectively. The $D_k$ are the possible set of
categories for each categorical variable $k$. Henceforth, we shall denote a
record as ${\bf r}=(v_1,v_2,\ldots,v_p,x_1,x_2,\ldots,x_q)=({\bf v},{\bf x})$, where
the $v_k$ are categorical and the $x_k$ are numerical variables.

The conditional edits that can be treated with the {\sf editrules} package can
be written as either
\begin{eqnarray}
\label{eqedit1}
\lefteqn{
\textrm{\sf if } {\bf Ax}\boldsymbol{\odot}{\bf b} \textrm{ \sf then } {\bf c\cdot x}\odot  d 
\textrm{, where }}\\
&&\begin{array}{l}
{\bf A} \in \mathbb{R}^{m\times q} \textrm{, }  
    {\bf b} \in \mathbb{R}^{m}\textrm{, }   
    \boldsymbol{\odot}\in\{<,\leq,\geq, >\}^m\\
    {\bf c} \in \mathbb{R}^{q}\textrm{, } 
    d \in \mathbb{R}\textrm{, } 
    \odot\in\{<,\leq,\geq, >\},\nonumber
\end{array}
\end{eqnarray}
or
\begin{eqnarray}
\label{eqedit2}
\lefteqn{
\textrm{\sf if } {\bf v}\in F \textrm{ \sf then } {\bf c\cdot x} \odot d,
\textrm{ \sf where }}\\
&& \begin{array}{l}
F \subset D_1 \times D_2 \times\cdots\times D_p,\\
\textrm{ and } {\bf c}\textrm{, }d\textrm{, }\odot\textrm{ as in Eq.\ \eqref{eqedit1}.} 
\end{array}\nonumber
\end{eqnarray}
Here, $F$ is used to denote a set of categorical edits, as defined in
\cite{loo:2011b}. It is important to note that equality restrictions are not
allowed in this formulation, neither in the premise, nor in the consequent. The
(technical) reason is that the logical negation of a linear equality yields a
nonlinear edit which prohibits certain operations such as variable elimination
by the Fourier-Motzkin procedure. Under the hood, negations of the premise or
consequents of conditional restrictions are often necessary to perform edit
manipulations. In practice, the lack of the {\tt ==} operator in conditional
edits poses no real restriction since any equality can be written as two
inequations.


Internally, conditional edits are represented by replacing each linear condition
with a dummy variable $t$, which is defined as
\begin{equation}
\label{eqdummy}
t = \left\{\begin{array}{l}
\true\textrm{ when } {\bf a\cdot x}\odot b\\
\false\textrm{ when }{\bf a\cdot x}\notodot b.
\end{array}\right.
\end{equation}
%
This way, the edits of Eq.\ \eqref{eqedit1} may be written as
\begin{equation}
\label{eqdummyedit1}
\textrm{\sf if } t_1\land t_2\land\cdots\land t_m \textrm{ \sf then } t_{m+1},
\end{equation}
where $t_1\cdots t_m$ correspond to the $m$ linear restrictions in the premise
of Eq.\ \eqref{eqedit1} and $t_{m+1}$ to the restriction in the consequent.
Similary, Eq.\ \eqref{eqedit2} may be rewritten as
\begin{equation}
\label{eqdummyedit2}
\textrm{\sf if } {\bf v} \in F \textrm{ \sf then } t,
\end{equation}
where $t$ corresponds to the linear restriction of Eq. \eqref{eqedit2}.
The restrictions of Eqs.\ \eqref{eqdummyedit1} and \eqref{eqdummyedit2}
are of a form that can be stored in a boolean representation  as described 
in \cite{loo:2011b} for the case of categorical variables. The {\sf editrules}
package uses an object class called {\sf editarray} to store such a
representation.

The linear restrictions which are replaced by the dummy variables can be
gathered in a matrix representation, as described in \cite{jonge:2011}. 
In {\sf editrules} such a representation is stored in an object of 
class {\sf editmatrix}. To store conditional edits, along
with pure numerical and pure categorical edits, we implemented the 
class {\sf editset}, which can be denoted as
\begin{equation}
\label{eqeditset}
E = \langle E_{\sf num}, E_{\sf mixnum}, E_{\sf mixcat};{\sf condition}\rangle.
\end{equation}
Here, $E_{\sf num}$ is an {\sf editmatrix} object holding numerical edits not
connected to any edits with nonnumerical variables. The object $E_{\sf mixnum}$
is an {\sf editmatrix}, holding numerical edits occurring in conditional edits.
The row names of $E_{\sf mixnum}$ correspond to dummy variables, occurring in the
categorical edits stored as an {\sf editarray} in $E_{\sf mixcat}$. The $E_{\sf
mixcat}$ object stores ``pure categorical'' edits, as well as conditional edits
containing dummy variables referring to edits in $E_{\sf mixnum}$. Finally, the
optional {\sf condition} attribute is an extra {\sf editmatrix} holding a
number of extra conditions (assumptions) under which the edits in $E_{\sf
num}$, $E_{\sf mixnum}$ and $E_{\sf mixcat}$ must hold. It will be discussed in
detail in Section \ref{sseditlist}. Under normal circumstances ({\em i.e.} if only
editrules built-in functions are used to build and manipulate {\sf editsets})
the {\sf condition} attribute will be present only when $E_{\sf mixnum}$
is empty.

The functionality of {\sf editrules} is implemented such that the user can
remain agnostic of the internal representation of edit sets. There is however a
second representation of conditional edits which is used and returned by
several basic manipulation functions. This representation, stored in the form
of an {\sf editlist} or {\sf editenv} will be described in Section
\ref{sseditlist}, but first we discuss how edits can be imported to and
exported from the {\sf R} environment.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\begin{figure}
\begin{Verbatim}[frame=single]
# define category domains
    BOOL <- c(TRUE,FALSE)
    OPTIONS <- letters[1:4]

# (conditional) numerical edits
    x + y == z
    2*u  + 0.5*v == 3*w
    w >= 0
    if ( x > 0 ) y > 0
    if ( x > y ) z < 10
    x >= 0
    y >= 0
    z >= 0

# categorical and mixed data edits
    A %in% OPTIONS
    B %in% OPTIONS
    C %in% BOOL
    D %in% letters[5:8]
    if ( A %in% c('a','b') ) y > 0
    if ( A == 'c' ) B %in% letters[1:3]
    if ( !C == TRUE) D %in% c('e','f')
\end{Verbatim}
\vspace{-0.8cm}
\caption{Example of a free-form textfile defining numerical, categorical and conditional 
edits. The edits can be read into {\sf R} with the {\sf editfile} function.}
\label{figeditfile}
\end{figure}
%

\subsection{Reading and writing edits}
As described in our previous papers on {\sf editrules}, edits can be read from
the commandline in {\sf character} form, or from a {\sf data.frame}. However it
is now also possible to read edits from {\sf R} {\sf expression} vectors or,
most conveniently, from a free-form text file.

As an example, Figure \ref{figeditfile} shows the contents of an example text file
that is included with the package. Observe that category domains may be defined
separately from the edits themselves. This is convenient for domains which are
reused over several variables or for large domains that need to be read from file. 
Numerical and categorical edits can be submitted as they would for objects
of class {\sf editmatrix} or {\sf editarray} respectively, while conditional
edits must follow the following syntax diagram.
%
\begin{syntdiag}
if ( 
\begin{rep}
    \begin{stack}
        <linear inequality>\\
        <set expression>
    \end{stack}\\
\begin{stack}   "&"\\"&&"\end{stack}
\end{rep}
)
\begin{rep}
    \begin{stack}
        <linear inequality>\\
        <set expression>
    \end{stack}\\
\begin{stack}   "|"\\"||"\end{stack}
\end{rep}
\end{syntdiag}
Here, \verb+&+ and \verb+&&+ and \verb+|+ and \verb+||+ are synonyms. The
symbol $\langle\textrm{\em set expression}\rangle$ is an expression indicating
set membership for categorical values, for example {\tt A \%in\% c("a","b")}. See
\cite{loo:2011b} for a syntax diagram of possible set expressions.  Comments
are allowed as well, and will be ignored by the parser. 

The example file of Figure \ref{figeditfile} can be read as follows:
<<>>=
myfile <- system.file("script/edits/myedits.txt",
    package="editrules")
(E <- editfile(myfile))
@
Here, {\sf E} is an object of class
{\sf editset}. When printed to screen, the datamodel for categorical variables,
as well as the textual representation of the edits are shown. For convenience,
edits are named according to their type.  Pure numerical edits are numbered
with prefix {\sf num}, pure categorical with prefix {\sf cat} and conditional
edits are prefixed with {\sf mix}. 



Edits can be selected with the bracket operator, using integer or logical indices,
for example:
<<>>=
E[c(7,10),]
@
By default, the full datamodel is retained when selecting a subset of edits.
Use the {\sf reduce} function to remove variables not occurring in any edit.

The function {\sf editfile} has an optional {\sf type} argument, allowing for
extracting only the numerical ({\sf type="num"}), categorical ({\sf
type="cat"}) or conditional edits ({\sf type="mix"}) from the textfile.  When
{\sf type="num"} or {\sf type="cat"}, an {\sf editmatrix} or {\sf editarray}
are returned respectively. Under the hood, {\sf editfile} parses the file,
looks for assignments (by {\sf <-} or {\sf =}) and evaluates them in a separate
{\sf R} {\sf environment}. Next, the edits are generated within that
environment.


To export edits, the most convenient way is to use either {\sf as.character} to
convert an {\sf editset} to text or {\sf as.data.frame} to convert it to a
2-column {\sf data.frame}. One can then use {\sf R}'s standard I/O
functionality to store edits as a structured text file, or use one of the
database interfaces to send edits to a database. When edits are read into
{\sf R}, the function {\sf editset} is capable of converting textual edits
to an {\sf editset} object. See Table \ref{tabcoercion} for an overview of
coercion options.


\begin{table}
\begin{threeparttable}
\caption{Functions for reading and coercing (conditional) edits.}
\label{tabcoercion}
\begin{tabular}{lp{0.7\textwidth}}
\hline
Function        & Description\\
\hline
{\sf editset}      & read from {\sf character} or {\sf expression} vector.\\
{\sf editfile}     & read from free-form textfile\\
{\sf as.character} & convert editset to {\sf character} vector\\
{\sf as.data.frame}& convert editset to two-column {\sf data.frame}\\ 
\hline
\end{tabular}
\end{threeparttable}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Untangling condtional edits}
\label{sseditlist}
%
\begin{figure}[t]
<<fig=TRUE,echo=FALSE>>=
par(oma=c(0,0,0,0),mar=c(0,0,1.5,0))
set.seed(2)
plot(E)
@
\caption{A graph view of the edits of Figure \ref{figeditfile}, generated  with
{\sf plot(E)}.  Squares represent edits, circles represent variables. An edge
indicates that a variable occurs in an edit. The {\sf blocks} function
separates an {\sf editset} into the independent editsets corresponding to the
independent graphs shown here. (Displayed using the {\sf igraph}
package of \cite{csardi:2006}.)}
\label{figgraph}
\end{figure}
%
%
As mentioned in the introduction, edits can be interrelated because an edit can
contain multiple variables and each variable can occur in multiple edits.  The
function {\sf contains} returns a boolean matrix, indicating which variables
occur in each edit. The default {\sf plot} function has been overloaded for
objects of class {\sf editset} (and {\sf editmatrix} and {\sf editarray}) to
generate a graphical display of such relations. Figure \ref{figgraph} shows
the dependency graph between the variables and edits of Figure
\ref{figeditfile}.

The set of edits clearly consists of three independent blocks. The function
{\sf blocks} separates an {\sf editset} into its constituting independent edits
and returns a {\sf list} of independent {\sf editset} objects. The {\sf blocks}
function has been introduced before in \cite{jonge:2011} and \cite{loo:2011b}
for {\sf editmatrix} and {\sf editarray} objects respectively.

To manipulate conditional edits, we first separate them by generating
combinations of truth values for the premise and consequent expressions.  This
way, all connections between numerical and categorical variables disappear at
the cost of generating multiple disjunct {\sf editsets} which may be treated
separately.

As an example, consider the following set of edits.
%
\begin{equation}
E = \left\{\begin{array}{l}
\textrm{\sf if } x \geq 0 \textrm{ \sf then } y\geq 0\\
\textrm{\sf if } x \geq 0 \textrm{ \sf then } x \leq y\\
\textrm{\sf if } x < 0 \textrm{ \sf then } y < 0\\
\textrm{\sf if } x < 0 \textrm{ \sf then } x - y < -2. \\
\end{array}\right.
\label{eqedits}
\end{equation}
These edits are all connected, since all of them contain both $x$ and $y$.
Figure \ref{figprojections} (page \pageref{figprojections}) shows (in grey) the
valid areas in the $x$-$y$ plane, defined by these edits. From the sketch it is
clear that the edits can be separated in two purely linear edit sets, and that
a record must obey the rules defining either the left, or the right grey area.
Algebraically, this can be done by working out the assumptions $x\leq 0$ is
$\true$ ($\false$) and consequently $x<0$ is $\false$ ($\true$). We obtain
\begin{equation}
E = \left(
x\geq0 \land  \left\{\begin{array}{l}
        y\geq 0\\
        x\leq y\\
\end{array}\right.,
x < 0 \land \left\{\begin{array}{l}
        y < 0\\
        x - y < 2\\
\end{array}\right.\right).
\label{eqeditlist}
\end{equation}
Here, each element consists of a conjunction of two sets of linear edits.  In
each element, the first edit set holds the conditions under which the edits in
the second set are valid. The fact that the conditions are mutually exclusive,
ensures that a record can be in the valid region defined by either one of the
elements of $E$, but not in both. 
%
%
\begin{algorithm}[t]
\caption{Determine all feasible convex regions of an {\sf editset}.}
\label{algeditlist}
\begin{algorithmic}[1]
    \State $S\leftarrow \varnothing$
    \Procedure{disjunct}{$E$}
    \State $T\leftarrow \{t : t \textrm{ is a dummy variable of }E \}$
    \If {$T = \varnothing$}
        \State $S \leftarrow S\cup E$
        \State {\bf return}
    \EndIf
        \State Choose a $t$ from $T$
        \State $E\leftarrow \textrm{\sf substValue}(E,t,\true)$
        \If { ${\textrm{\sf isFeasible}\left(E_{\sf num}\cup \textrm{\sf condition}(E)\right)} \land \textrm{\sf isFeasible}(E_{\sf mixnum})$ }
\label{algp1}  
        \State $\textrm{\sc disjunct}(E)$
        \EndIf
        \State $E\leftarrow \textrm{\sf substValue}(E,t,\false)$
        \If { ${\textrm{\sf isFeasible}\left(E_{\sf num}\cup \textrm{\sf condition}(E)\right)} \land \textrm{\sf isFeasible}(E_{\sf mixnum})$ }
\label{algp2} 
        %\If { $E_{\sf num}$, {\sf condition($E$)} and $E_{\sf mixnum}$ all feasible }
        \State $\textrm{\sc disjunct}(E)$
        \EndIf
    \EndProcedure
\end{algorithmic}
\end{algorithm}

The above example is generalized by the recursive procedure shown in Algorithm
\ref{algeditlist}. The algorithm runs depth-first through a binary tree,
generating all possible assumptions about the truth values of linear
edits that occur in the premise or consequent of a conditional edit. Each
leaf of the tree corresponds to one complete set of assumptions about the
truth values of the linear restrictions occurring in conditional edits.

Assumping a truth value for a premiss or consequent amounts to substituting a
the value of a dummy variable in the $E_{\sf mixnum}$ part of an {\sf editset},
copying the assumption to the {\sf condition}  attribute of the {\sf editset},
and updating $E_{\sf mixcat}$ and $E_{\sf mixnum}$ accordingly.  The {\sf
substValue} function, which will be discussed in more detail in Section
\ref{sssubstitution}, is equipped to do this. 

To save computational time, the tree is pruned whenever an inconsistent set of
edits arises, so no spurious edit sets are generated. The procedure uses the
function {\sf isFeasible} on objects of class {\sf editmatrix} and {\sf
editarray} which have been discussed in \cite{jonge:2011} and \cite{loo:2011b}
respectively.  Note that in the pruning conditions in lines \ref{algp1} and
\ref{algp2}, the feasibility of the union of $E_{\sf num}$ with the generated
numerical conditions is checked. This is done to make sure that no conditions
can arise that contradict the pure numerical edits. This can only happen when
the {\sf editset} contains internal contradictions, and implementing it this
way will help idendifying infeasible sets of conditional edits, to be discussed
in Section \ref{sselimination}. Feasibility checks can be computationally
expensive, so some short-circuiting is done in the implementation {\sf R} of
lines \ref{algp1} and \ref{algp2} to avoid unnecessary computations.


The {\sf editrules} function {\sf disjunct} implements the procedure of
Algorithm~\ref{algeditlist}. The name ``disjunct'' derives from the fact that a
valid record is in precisely one of the regions defined by the resulting set of
{\sf editset} objects.  By default the {\sf disjunct} function returns all
editsets as a {\sf list}. However, operations on lists can be time-consuming
when elements in a list have to be treated and replaced one by one. For this
reason, {\sf disjunct} accepts an optional {\sf type} argument.  If {\sf
type="env"}, the set of {\sf editsets} are returned as an environment, which
may be used to avoid unnecessary copying. To allow overloading of functions
such as {\sf eliminate} and {\sf localizeErrors}, the result of {\sf disjunct}
is of class {\sf editlist} or {\sf editenv}. 

\begin{figure}
<<fig=true,echo=false>>=
v <- disjunct(E)
par(oma=c(0,0,0,0),mar=c(0,0,1.5,0),mfrow=c(2,2),pty='m')
for ( i in 1:length(v) ){
    set.seed(1)
    plot(
        v[[i]],
        main=paste(as.character(editrules:::condition(v[[i]])),collapse=', ')
    )
}
@
\caption{Connectivity graphs of the disjunct edit sets
generated from the edits of Figure \ref{figeditfile}. There are no paths from
numerical variables ($x$, $y$, $z$, $u$, $v$, $w$) to categorical 
variables ($A$, $B$, $C$, $D$) anymore. The titles of the subplots indicate
the conditions for each editset.}
\label{figdisjunct}
\end{figure}
%
%
As an example of how {\sf disjunct} separates numerical from categorical
variables, the four editsets, resulting from passing the edits of Figure
\ref{figeditfile} to {\sf disjunct} are plotted in Figure \ref{figdisjunct}.
The original editset has three dummy variables, corresponding to $x>0$, $y>0$,
and $x>y$, yielding eight disjunct spaces. Four of these are empty, because not
all combinations of truth values are valid. For example, the conditions
$x>y=\true$, $x>0=\false$ and $y>0=\true$ contradict.  Note that contrary to
Figure \ref{figgraph}, there are no paths connecting numerical variables
($x$,$y$,$z$,$u$,$v$,$w$) to categorical variables ($A$, $B$, $C$, $D$) in any
of the dependency graphs.
%
\begin{table}[t]
\caption{Edit separation functions. Each function accepts an {\sf editset} as input.}
\label{tabseparators}
\begin{tabular}{lp{0.8\textwidth}}
\hline
Function & Description\\
\hline
{\sf blocks}   & Splits an {\sf editset} in independent edits not sharing any variables.\\
{\sf disjunct} & Splits an {\sf editset} in disjunct sets, not containing mixed edits.\\
{\sf condition} & Returns the {\sf editmatrix} holding the conditions for an {\sf editset} generated by {\sf disjunct}.\\
{\sf separate} & Uses {\sf blocks}, simplifies the results, and calls {\sf disjunct} on the remaining {\sf editset}s.\\
\hline
\end{tabular}
\end{table}

Finally, we note the {\sf separate} function that combines {\sf blocks} and
{\sf disjunct}. Function {\sf separate} blocks an editset based on variable
occurrence and simplifies the blocks to objects of class {\sf editmatrix} or
{\sf editarray} where possible. After this, the remaining {\sf editset} objects
are split into an {\sf editlist} using {\sf disjunct}. The result is returned
as an {\sf R} {\sf list}. Table \ref{tabseparators} summarizes the edit
separation functions.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Edit checking, obvious redundancy and (in)feasibility}
Data can be checked against edits in an editset with the {\sf violatedEdits}
function. This function accepts an {\sf editset} and a {\sf data.frame} and
returns a logical array (of class {\sf violatedEdits}) where each row and
column indicates which record violates what edit. A {\sf summary} and {\sf
plot} method is available for {\sf violatedEdits} objects so users can get a
quick overview of edit violation frequencies. Internally, the {\sf
violatedEdits} method for editsets works by coercing the edits to logical {\sf
character} expression and using {\sf R}'s evaluation functionality to parse and
evaluate these expressions in the context of the {\sf data.frame}. 

An edit in an {\sf editset} is obviously redundant when it is the duplicate of
another edit or when it has an easily recognizable form such as $0 < 1$. Such
redundancies may arise after edit manipulations (value substitution, variable
elimination).  The {\sf isObviouslyRedundant} method for {\sf editset} returns
a logical vector indicating which edit in an editset is redundant (\true) or
not (\false). For an {\sf editlist} ({\sf editenv}) a list of boolean vectors
is returned. For a detailed description of detecting obvious redundancies in
numerical or categorical edits, refer to \cite{jonge:2011} and
\cite{loo:2011b}.

The {\sf S3} methods of {\sf isObviouslyInfeasible} for objects of class {\sf
editset} and {\sf editlist} use the methods previously implemented for objects
of class {\sf editarray} and {\sf editmatrix}. For an {\sf editset}, {\sf
isObviouslyInfeasible} returns \true if either the $E_{\sf num}$ or the $E_{\sf
mixcat}$ [See Eq. \eqref{eqeditset}] part contains an obvious contradiction. For
objects of class {\sf editlist} or {\sf editenv} a vector of logicals is
returned. Note that the presence of an obvious contradiction is sufficient, but
not necessary for a set of edits to be infeasible. To prove (in)feasibility,
one needs to call {\sf isFeasible}, which is usually a much more expensive
calculation.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Manipulation of conditional edits}
\label{smanipulation}
The two basic operations on any set of restrictions, either numerical,
categorical, or mixed/conditional consist of value substitution and variable
elimination. Methods for the pure numerical and pure categorical situations are
fairly straightforward and have been implemented in the {\sf editrules} package
before. Operations on conditional edits require a bit more care, which will
be detailed in the next two subsections.

\subsection{Value substitution}
\label{sssubstitution}
Recall that conditional edits in an {\sf editset} are stored as a combination of
categorical edits on dummy variables, that to linear edits in $E_{\sf mixnum}$.
Purely numerical edits are stored in a separate subobject called $E_{\sf num}$.
To substitute a value in an {\sf editset}, four cases are distinguished.

The first two cases are the simplest and concern variables which are either
numerical and not occurring in $E_{\sf mixnum}$ or categorical variables. These
cases are handled by dispatching the appropriate {\sf substValue} methods for
$E_{\sf num}$ or $E_{\sf mixcat}$ ({\sf editmatrix} and {\sf editarray}
respectively) which have been described in \cite{jonge:2011} and
\cite{loo:2011b}.

The third case occurs when the substituted variable is a numerical variable,
occurring in the premise or consequent of a conditional edit. In that case
the following actions are performed.
%
\begin{enumerate}
\item If the variable occurs in $E_{\sf num}$ substitute its value there.
\item Substitute the variable in $E_{\sf mixnum}$.
\item If any edits in $E_{\sf mixnum}$ have become obviously redundant ({\em e.g.} $0 < 1$) or
obvious contradictions ({\em e.g.} $1 < 0$), substitute respectively \true or \false for
the corresponding dummy variables in $E_{\sf mixcat}$.
\item Remove all edits of the form $\textrm{\sf if } \true \textrm{ \sf then  } t$
from $E_{\sf mixcat}$. (Recall that $t$ is a dummy variable, see Eqs.\ \eqref{eqdummy}-\eqref{eqdummyedit2}).
\item If the dummy variables $t$ of step 4 do not occur anywhere in $E_{\sf
mixcat}$ anymore, move the corresponding linear inequality from $E_{\sf mixnum}$ to $E_{\sf num}$.
\item Remove all edits of the form $\textrm{\sf if } \false \textrm{ \sf then  } t$.

\end{enumerate}
%
%
As an example, consider the code below.
<<>>=
F <- editset(expression(
x + y == z,
if ( x > 0 ) y > 0))
substValue(F,"x",3)
@
Here, substituting $x=3$, yields $\textrm{\sf  if } \true \textrm{ \sf  then } y>0$, so the 
consequent $y>0$ may be added to the numerical edits (here: $x+y=z$). 
On the other hand, substituting $x = -3$ gives $\textrm{\sf  if } -3 > 0 \textrm{ \sf  then } y>0$,
yielding a false premise and the conditional edit can be deleted:
<<>>=
substValue(F,"x",-3)
@

The fourth and final case concerns substitution of dummy variables.  Recall
that dummy variables are used to code linear inequalities that occur in
conditional edits. Filling in \true or \false for a dummy variable is not the
same substituting a value for a variable that is subject to the edit rules.
Rather, it is equivalent to asserting that a linear relationship on one or more
variables holds.  If a dummy variable is substituted, {\sf substValue} moves
the corresponding numerical edit from $E_{\sf mixnum}$ to the {\sf condition}
attribute of the {\sf editset}. Next, $E_{\sf mixcat}$ is updated accordingly.
Substituting dummy variables explicitly is not normally done by end users, as
the names and values of dummy variables remain hidden to them.  It is used
internally by {\sf disjunct}. The {\sf condition} attribute is stored as an
{\sf editmatrix} and can be requested with the {\sf condition} function.
%
%
\setkeys{Gin}{width=0.5\textwidth}
\begin{figure}
\centering
<<fig=true,echo=false>>=
    par(mar=rep(0,4),oma=rep(0,4))
    lwd=2
    pcol <- "#E3E3E3" 
    x <- c(0,4)
    plot(x,x,"l",axes=FALSE,xlab="",ylab="",xlim=c(-4,4),ylim=c(-2,3),lwd=lwd)
    polygon(c(0,3.9,3.9),c(0,3.9,0),border=NA,col=pcol)
    polygon(c(-2,-3.9,-3.9),c(0,0,-1.9),border=NA,col=pcol)
    lines(x,x,lwd=lwd)
    abline(v=0,lwd=lwd)
    abline(h=0,lwd=lwd)
    x2 <- c(-2,-4)
    lines(x2,x2+2,lwd=lwd)
    lines(c(0,5),c(0,0),lwd=5)
    points(0,0,pch=16,cex=2)
    lines(c(-2,-5),c(0,0),lwd=5)
    text(4,-0.2,expression(x),cex=2)
    text(-0.2,3,expression(y),cex=2)
@
\caption{Graphical representation (in grey) of the valid areas defined by the
edits of Eq.\ \eqref{eqedits}. Depicted are sections of the bordering lines
$y=x$ and $y=x+2$.  The bold lines indicate the projections of the grey areas
along the $y$-axis.
}
\label{figprojections}
\end{figure}


\subsection{Variable elimination and satisfiability}
\label{sselimination}
Variable elimination on an editset is executed by first separating the edits in
disjunct sets where no numerical edits appear in conditional edits anymore (See
Section \ref{sseditlist}).  Next, since in each element of the resulting
editlist, the dummy {\sf editmatrix} $E_{\sf mixnum}$ is empty, variable
elimination takes place on each $E_{\sf num}$ or $E_{\sf mixcat}$ of the {\sf
editlist} for numerical or categorical variables respectively. The methods used
for variable elimination in an {\sf editmatrix} are described in {\sf
jonge:2011} while the methods for variable elimination from an editarray are
described in \cite{loo:2012}. Consequently, the result of
an {\sf eliminate} operation is an object of class {\sf editlist}. 

As an example, consider again the set of edits of Eqs.~\eqref{eqedits}
and~\eqref{eqeditlist}. In Figure~\ref{figprojections}, the valid regions are
indicated as grey areas.  Geometrically, eliminating variable $y$ amounts to a
projection along the $y$-axis (or along the $x$-axis when $x$ is eliminated).
Figure \ref{figprojections}  shows the result of projecting out the $y$
variable (in bold lines).  Algebraically, we need to apply Fourier-Motzkin
elimination on the second set of linear edits of each element of
Eq.~\eqref{eqeditlist} to obtain
\begin{displaymath}
E = \left(
x\geq0 \land  \varnothing
,
x < 0 \land x < -2\right).
\end{displaymath}
The first edit element says that if $x\geq 0$, there are no further restrictions.
The second element says that when $x<0$, it must be smaller than $-2$. Figure
\ref{figelimination} shows how the results are displayed in {\sf R} by {\sf editrules}.


\setcounter{Rcode}{\value{figure}}
\begin{Rcode}[t!]
<<>>=
E <- editset(expression(
    if ( x >= 0 ) y >= 0,
    if ( x >= 0 ) x <= y,
    if ( x < 0 ) y < 0,
    if ( x < 0 ) x - y < -2
))
eliminate(E,"y")
@
\caption{Eliminating a variable from an object of class {\sf editset} results in an {\sf editlist}.}
\label{figelimination}
\end{Rcode}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Error localization in mixed data}
\label{serrorlocalization}

\subsection{A branch-and-bound algorithm}
The error localization problem consists of finding the least (weighted) amount
of fields in a record that can be adapted or imputed, such that no edits are
violated anymore. For purely categorical or purely numerical edit sets, the
feasible space of records is convex, and each solution can be determined by a
sequence of variable substitutions or eliminations.  For objects of class {\sf
editmatrix} and class {\sf editarray} a branch-and-bound algorithm generating
such sequences has been implemented before \citep{jonge:2011,loo:2011b}.
When conditional edits are present, as in the example of Figure
\ref{figprojections}, solving an error localization problem is equivalent to
solving it for each convex subregion separately and selecting the lowest-weight
solution afterwards. 

In {\sf editrules}, error localization with conditional edits (in an {\sf
editset}) starts by separating the edits into blocks and disjunct sets
using the {\sf separate} function discussed in Section \ref{sseditlist}.
Separate blocks share no variables and are treated indepenently. Blocks
consisting of {\sf editmatrix} or {\sf editarray} objects are treated as
described in the references mentioned before. Blocks consisting of {\sf
editlists} have to be treated differently. Remember that an {\sf editlist} is a set
of {\sf editsets}, each describing a convex region of the record domain. An
{\sf editlist} enters a similar branch-and-bound algorithm as {\sf
editmatrices} and -{\sf arrays}, with the difference is that each
elimination and subsitution step is performed separately on each element of an
{\sf editlist}.  Whenever one of the elements of an {\sf editlist} becomes
infeasible it is removed from the list. When no feasible regions are left and
not all variables have been treated, a bound condition is hit and the branch is
pruned. If all variables have been treated, and no inconsistencies were
encountered, a (list of) solutions is found. When all solution (lists) are
found, the lowest weight solution can be selected.

The process is accelerated by detecting whenever the current weight of partial
solutions equals the weight of previous solutions. At that point, all remaining
values are substituted to check whether the branch can lead to an actual
solution. If so, the solution is stored; if not, a bound condition is hit. 


\subsection{Acceleration by datamodel checking}
Observe that the number of nodes of the branch-and-bound tree grows as $2^n$,
with $n$ the number of variables (and hence the depth of the tree).  In some
cases the tree depth can be reduced by noting that variables which violate
simple, single-variable range edits will always be part of the error
localization solution. These single-variable edits are easily checked (in a
vectorized manner) and variables violating such edits can be removed from the
multivariate localization problem. 

The solution to an error localization problem for a number of records in a
dataset with $n$ variables can be represented as matrix ${\bf M}$ where
$M_{ij}>0$ if variable $j$ in record $i$ must be changed and $0$ otherwise.  To
construct such a matrix, we assume a set of single-variable edits, and
proceed as follows.  Suppose that ${\bf V}$ is a matrix where $V_{ik}=1$ if
record $i$ violates edit $k$ and $0$ otherwise.  To account for missing values,
we also set $V_{ik}=1$ when edit violation cannot be established because the
value of the variable to which range edit $k$ pertains is missing.  Also,
suppose that ${\bf C}$ is a matrix where $C_{kj}=1$ if edit $k$ contains
variable $j$ and $0$ otherwise. The matrix ${\bf M}$ is then given by
\begin{equation}
{\bf M} = {\bf V}{\bf C}.
\end{equation} 

In {\sf editrules}, this operation has been implemented in the function {\sf checkDatamodel}.
This function returns an object of class {\sf errorLocation}, but does not yield a full solution,
as demonstrated by the example of Figure \ref{R:checkdatamodel}.

\begin{Rcode}
<<>>=
E <- editmatrix(expression(
    x > 0,
    x + y == 2
))
(dat <- data.frame(x=c(-1,2),y=c(3,0)))
checkDatamodel(E,dat)$adapt
localizeErrors(E,dat)$adapt
@
\caption{An example of {\sf checkDatamodel}, which only detects violation of range edits,
while {\sf localizeErrors} finds the full solution.
}
\label{R:checkdatamodel}
\end{Rcode}

\subsection{Error localization with {\sf localizeErrors} and {\sf errorLocalizer}}
The interfaces of {\sf localizeErrors} and {\sf errorLocalizer} for objects
of class {\sf editset} are similar to those of {\sf editmatrix} and {\sf editarray}.
They will therefore not be described extensively here, in stead we refer the
reader to \cite{jonge:2011a} and \cite{loo:2011b}. In short, function {\sf localizeErrors}
accepts an {\sf editset} and a {\sf data.frame} along with some optional arguments and
returns an object of class {\sf errorLocation}. The function {\sf errorLocalizer} returns
a {\sf backtracker} object that allows fine control over the branch-and-bound search
algorithm.

New to version {\sf 3.0} of the package is that {\sf localizeErrors} uses {\sf
checkDatamodel} to identify fields that fail range edits prior to entering the
branch-and-bound algorithm.  We note that for large, highly entangled edit
sets, especially those with many conditionals edits, the branch-and-bound
algorithm may take a long time to complete. For this reason a second backend
algorithm has been implemented, that uses a mixed-integer programming
formulation of the localization problem. It can be accessed by providing the
optional parameter {\sf method="mip"} to {\sf localizeErrors}. For a comparison
between the two algorithms refer to \cite{jonge:2012}.

\section{Conclusions}
We have described new functionality of the {\sf editrules} package, pertaining
to conditional restrictions and mixed data edits. All existing edit manipulation
functions have been overloaded to handle the new {\sf editset} object.

Several new edit manipulation features have been added, most notably the
possibility to split sets of edits in disjunct sets that do not contain any
mixed data edits anymore. Also, the branch-and-bound error localization methods
have been accelerated by taking care of range edit violations prior to
multivariate error localization.

Future work on the package may include the extension to {\em soft edits}, where
not only the violation of an edit is weighed in the process of error
localization but also the {\em amount} of violation is somehow taken into
account.


\label{sconclusions}

\clearpage
\bibliographystyle{chicago}
\bibliography{editrules}

\clearpage
\addcontentsline{toc}{section}{Index}
\printindex



\end{document}


