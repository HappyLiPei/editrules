%\VignetteIndexEntry{Manipulation of categorical data edits and error localization with the editrules package}
\documentclass[11pt, fleqn, a4paper]{article}
\usepackage{inconsolata}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{array}
\usepackage[rounded]{syntax}
\usepackage{color, colortbl}
\usepackage{tex/smalltree}
\usepackage{natbib}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}
\usepackage{makeidx}
\usepackage{mySweave}
\makeindex

% shorthand to make '<category>' in syntax diagram
\newcommand{\syncat}{ $\textrm{\sf '}\langle category\rangle\textrm{\sf '}$ }
\newcommand{\notodot}{\odot\kern-0.85em/\:\,}

\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\Lor}{\lor}
\DeclareMathOperator*{\Land}{\land}
\DeclareMathOperator{\ocup}{\cup}
\DeclareMathOperator{\ocap}{\cap}
\DeclareMathOperator{\res}{\mathfrak{R}}
\newcommand{\rhomap}{\xrightarrow{\rho}}
\newcommand{\rows}{\textrm{rows}}
\newcommand{\columns}{\textrm{columns}}
\newcommand{\ind}{\textrm{\bf ind}}
\newcommand{\true}{\textrm{\sc true} }
\newcommand{\false}{\textrm{\sc false} }

\newtheorem{theorem}{Theorem}[subsection]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newcommand{\theend}{\hfill$\Box$}


\usepackage{float}
 
\floatstyle{boxed}
\newfloat{Rcode}{t!}{rco}
\floatname{Rcode}{Figure}



% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}
\hyphenation{
    time-stamp 
    se-pa-ra-te-ly
    ge-ne-ra-li-zed
    e-dit-rules
}

<<echo=false>>=
library(editrules)
@

\title{Manipulation of conditional restrictions and error localization with the
    {\sf editrules} package\\
{\small package version \Sexpr{packageVersion("editrules")}}}
\author{Mark van der Loo and Edwin de Jonge}
\begin{document}
\maketitle
\begin{abstract}
{\em This vignette is far from finished. Version 3.0 of the package will have the
full vignette.}


Analyses of categorical data are often hindered by the occurrence of
inconsistent or incomplete raw data. Although {\sf R} has many features for
analyzing categorical data, the functionality for error localization and error
correction are currently limited.  The {\sf editrules} package is designed to
offer a user-friendly toolbox for edit definition, manipulation, and error
localization based on the generalized paradigm of Fellegi and Holt.  

This is the third paper describing functionalities of the {\sf R} {\sf
editrules} package and marks the completion of {\sf editrules} version $3.0$.
The first paper \citep{jonge:2011} describes methods and implementation for
handling numerical data, the second paper \citep{loo:2011b} describes methods and implementation
for handling categorical data, while this paper is concerned with mixed 
data and conditional restrictions. A fourth paper \citep{jonge:2011b} is dedicated
to error localization as a mixed integer problem.


%{\em For package version 3.0-0, this vignette is a near literal 
%    transcript of \cite{loo:2011b}. Please refer to that paper
%    when referencing categorical data handling with {\sf editrules}.
%    This vignette will be updated with the package if necessary.}

\end{abstract}

\newpage
\tableofcontents
\listofalgorithms

\newpage


\section{Introduction}
\label{sIntroduction}
Analyses of categorical data are often hindered by occurrences of incomplete or
inconsistent raw data records.  The process of locating and correcting such
errors is referred to as {\em data editing}, and it has been estimated that
National Statistics Institutes spend up to 40\% of their resources on this
process \citep{waal:2011}. For this reason, considerable attention is paid to
the development of data editing methods that can be automated. 

In the practive of (official) statistics, data records are often required to obey 
various restrictions, including sum rules, positivity demands or other linear
inequalities, and categorical restictions which exclude certain value combinations.
In literature on data editing, such restrictions are often called {\em edit rules}
or {\em edits}, in short.

Data editing is severely complicated by the fact that the fact that these rules
are often interrelated: a variable can occur in more than one restriction, and
a restriction can contain more than a single variable. Sets of restrictions on
purely numerical or purely categorical data have been treated in our previous
papers on the editrules package \citep{jonge:2011,loo:2011b}. Here, we extend
our treatment to restrictions which are related by conditional statements. An
example of such a statement, connecting a categorical variable {\em legal
form} with a numerical variable ({\em number of employees}), is
\begin{quote}
If the legal form (of a business) is self-employed, the number of employees must be zero.
\end{quote}
\cite{waal:2003} and \cite{waal:2003a} showed that every edit containing catorical as
well as numerical data can be written in such a form. That is, all
restrictions on categorical data occur in the predicate and numerical restrictions
occur in the consequent expression. The formulation is general enough to encompass
purely numerical restrictions (the predicate becomes {\sc true}) as well as purely
categorical rules (the consequent becomes {\sc false}).
However, rules connecting numerical restrictions are not uncommon, as shown by
the following example, which is commonly applied to business surveys.
\begin{quote}
If the number of employees is positive, the amount of salary payed must be
positive.
\end{quote}

The purpose of this paper is to present version 3.0 of the {\sf R} extension
package {\sf editrules}. This package extends the functionality of the previous
versions by introducing the ability to parse, manipulate conditional
restrictions and to apply them to data. The package can handle restrictions
where numerical restrictions occur in the predicate as well as in the
consequent, and extends the methodology described by \cite{waal:2003}.  The
basic manipulations on edits which were introduced in the previous versions for
numerical or categorical data are extended here to include conditional
restrictions. These manipulations include, but are not limited to, redundancy
checking, block decomposition, variable elimination and value substitution.
Error localization for data under conditional edits based the generalized
Fellegi-Holt assumption \cite{fellegi:1976} is provided as well. Error
localization has been implemented based on two computational methods. One based
on a branch-and-bound algorithm and one based on a mixed-integer formulation.
Here, the branch-and-bound formulation will be discussed, leaving treatment of
the mixed-integer approach to a seperate paper \citep{jonge:2011b}.

The rest of this paper is structured as follows. In Section \ref{smixeddata}
we describe which restrictions can be handled by the package, and introduce
the central object for handling conditional restrictions: the {\sf editset}
object. In Section \ref{smanipulation} we provide details on the most important 
edit manipulations that the package provides and Section \ref{serrorlocalization}
is devoted to error localization. Examples in {\sf R} code are given throughout
to aide new users getting started with this functionality.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mixed data and conditional edits}
\label{smixeddata}
The term ``mixed data'' is used here to indicate data containing both numerical
and categorical data. We do not distinguish between integer and real numbers
here: currently, both are handled as real numbers by editrules. We also do not
distinguish between logical and categorical data: under the hood, editrules
handles these data types as {\sf character}, although a user need not consider
this when specifying types (see also \cite{loo:2011b}).

\subsection{The {\sf editset} object}
A record in a mixed dataset can be described as an element of the domain
\begin{equation}
R = D_1\times D_2\times\cdots\times D_p\times \mathbb{R}^{q}.
\end{equation}
Here, $p$ and $q$ are positive integers that denote the number of categorical
and numerical variables respectively. The $D_k$ are the possible set of
categories for each categorical variable $k$. Henceforth, we shall denote a
record as ${\bf r}=(v_1,v_2,\ldots,v_p,x_1,x_2,\ldots,x_q)=({\bf v},{\bf x})$, where
the $v_k$ are categorical and the $x_k$ are numerical variables.

The conditional edits that can be treated with the {\sf editrules} package can
be written as either
\begin{eqnarray}
\label{eqedit1}
\lefteqn{
\textrm{\sf if } {\bf Ax}\boldsymbol{\odot}{\bf b} \textrm{ \sf then } {\bf c\cdot x}\odot  d 
\textrm{, where }}\\
&&\begin{array}{l}
{\bf A} \in \mathbb{R}^{m\times q} \textrm{, }  
    {\bf b} \in \mathbb{R}^{m}\textrm{, }   
    \boldsymbol{\odot}\in\{<,\leq,\geq, >\}^m\\
    {\bf c} \in \mathbb{R}^{q}\textrm{, } 
    d \in \mathbb{R}\textrm{, } 
    \odot\in\{<,\leq,\geq, >\},\nonumber
\end{array}
\end{eqnarray}
or
\begin{eqnarray}
\label{eqedit2}
\lefteqn{
\textrm{\sf if } {\bf v}\in F \textrm{ \sf then } {\bf c\cdot x} \odot d,
\textrm{ \sf where }}\\
&& \begin{array}{l}
F \subset D_1 \times D_2 \times\cdots\times D_p,\\
\textrm{ and } {\bf c}\textrm{, }d\textrm{, }\odot\textrm{ as in Eq.\ \eqref{eqedit1}.} 
\end{array}\nonumber
\end{eqnarray}
Here, $F$ is used to denote a set of categorical edits, as defined in
\cite{loo:2011b}. It is important to note that equality restrictions are not
allowed in this formulation, neither in the premise, nor in the consequent. The
(technical) reason is that the logical negation of a linear equality yields a
nonlinear edit which prohibits certain operations such as variable elimination
by the Fourier-Motzkin procedure. Under the hood, negations of the premise or
consequents of conditional restrictions are often necessary to perform edit
manipulations.

Internally, such conditional edits are represented by replacing each linear condition
with a dummy variable $t$, which is defined as
\begin{equation}
\label{eqdummy}
t = \left\{\begin{array}{l}
\true\textrm{ when } {\bf a\cdot x}\odot b\\
\false\textrm{ when }{\bf a\cdot x}\notodot b.
\end{array}\right.
\end{equation}
%
This way, the edits of Eq.\ \eqref{eqedit1} may be written as
\begin{equation}
\label{eqdummyedit1}
\textrm{\sf if } t_1\land t_2\land\cdots\land t_m \textrm{ \sf then } t_{m+1},
\end{equation}
where $t_1\cdots t_m$ correspond to the $m$ linear restrictions in the premise
of Eq.\ \eqref{eqedit1} and $t_{m+1}$ to the restriction in the consequent.
Similary, Eq.\ \eqref{eqedit2} may be rewritten as
\begin{equation}
\label{eqdummyedit2}
\textrm{\sf if } {\bf v} \in F \textrm{ \sf then } t,
\end{equation}
where $t$ corresponds to the linear restriction of Eq. \eqref{eqedit2}.
The restrictions of Eqs.\ \eqref{eqdummyedit1} and \eqref{eqdummyedit2}
are of a form that can be stored in a boolean representation  as described 
in \cite{loo:2011b} for the case of categorical variables. The editrules
package uses an object class called {\sf editarray} to store such a
representation.

The linear restrictions which are replaced by the dummy variables can be
gathered in a matrix representation, as described in \cite{jonge:2011}. 
In {\sf editrules} such a representation is stored in an object of 
class {\sf editmatrix}. To store conditional edits, along
with pure numerical and pure categorical edits, we implemented the 
class {\sf editset}, which can be denoted as
\begin{equation}
\label{eqeditset}
E = \langle E_{\sf num}, E_{\sf mixnum}, E_{\sf mixcat}\rangle.
\end{equation}
Here, $E_{\sf num}$ is an {\sf editmatrix} object holding numerical edits
not connected to any edits with nonnumerical variables. The object
$E_{\sf mixnum}$ is an {\sf editmatrix}, holding numerical edits occuring
in conditional edits. The rownames of {\bf mixnum} correspond to 
dummy variables, occuring in the categorical edits stored as 
an {\sf editarray} in $E_{\sf mixcat}$. The $E_{\sf mixcat}$ object stores
``pure categorical'' edits, as well as conditional edits containing
dummy variables referring to edits in $E_{\sf mixnum}$.

The functionality of {\sf editrules} is implemented such that the user can
remain agnostic of the internal representation of edit sets. There is however a
second representation of conditional edits which is used and returned by
several basic manipulation functions. This representation, stored in the form
of an {\sf editlist} or {\sf editenv} will be described in Section
\ref{sseditlist}, but first we discuss how edits can be imported to and
exported from the {\sf R} environment.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Reading and writing edits}
As described in our previous papers on {\sf editrules}, edits can be read from
the commandline in {\sf character} form, or from a {\sf data.frame}. However it
is now also possible to read edits from {\sf R} {\sf expression} vectors or,
most conveniently, from a free-form textfile.
%
\begin{figure}
\begin{Verbatim}[frame=single]
# define category domains
    BOOL <- c(TRUE,FALSE)
    OPTIONS <- letters[1:4]

# numerical edits
    x + y == z
    2*u  + 0.5*v == 3*w
    w >= 0
    if ( x > 0 ) y > 0
    if ( x > y ) z < 10
    x >= 0
    y >= 0
    z >= 0

# categorical edits
    A %in% OPTIONS
    B %in% OPTIONS
    C %in% BOOL
    D %in% letters[5:8]
    if ( A %in% c('a','b') ) y > 0
    if ( A == 'c' ) B %in% letters[1:3]
    if ( !C == TRUE) D %in% c('e','f')
\end{Verbatim}
\caption{Example of a free-form textfile defining numerical, categorical and conditional 
edits. The edits can be read into {\sf R} with the {\sf editfile} function.}
\label{figeditfile}
\end{figure}

For example, in Figure \ref{figeditfile} the contents of an example textfile is
printed. Note that it is possible to define the domains of categories
separately from the edits themselves, which is convenient for domains which are
reused over several variables. Comments are allowed as well, and will be ignored
by the parser. If the file is stored in a file called {\sf myedits.txt}, the
file can be read as follows:
<<>>=
myfile <- system.file("script/edits/myedits.txt",package="editrules")
(E <- editfile(myfile))
@
Here, {\sf E} is an object of class {\sf editset}. When printed to screen,
the datamodel for categorical variables, as well as the textual representation
of the edits are shown. For convenience, edits are named according to their type.
Pure numerical edits are numbered with prefix {\sf num}, pure categorical with
prefix {\sf cat} and conditional edits are prefixed with {\sf mix}. Edits
can be selected with the bracket operator, using integer or logical indices,
for example:
<<>>=
E[c(7,10),]
@
By default, the full datamodel is retained. The {\sf reduce} function removes
all variables numerical variables not occurring in any edit and all categorical
variables not occurring in a multivariate edit.

The function {\sf editfile} has an optional {\sf type} option, allowing for
extracting only the numerical ({\sf type="num"}), categorical ({\sf
type="cat"}) or conditional edits ({\sf type="mix"}) from the textfile.  When
{\sf type="num"} or {\sf type="cat"}, an {\sf editmatrix} or {\sf editarray}
are returned respectively. Under the hood, {\sf editfile} parses the file,
looks for assignments (by {\sf <-} or {\sf =}) and evaluates them in a separate
{\sf R} {\sf environment}. Next, the edits are generated within that
environment.

In summary, each conditional edit definition is of the form, indicated by the
following syntax diagram.
\begin{syntdiag}
if ( 
\begin{rep}
    \begin{stack}
        <linear inequality>\\
        <set expression>
    \end{stack}\\
\begin{stack}   "&"\\"&&"\end{stack}
\end{rep}
)
\begin{rep}
    \begin{stack}
        <linear inequality>\\
        <set expression>
    \end{stack}\\
\begin{stack}   "|"\\"||"\end{stack}
\end{rep}
\end{syntdiag}
Here, a $\langle\textrm{\em set expression}\rangle$ is an expression indicating
set membership of categorical variables, such {\tt A \%in\% c("a","b")}. See
\cite{loo:2011b} for a complete syntax diagram of possible set expressions.

To export edits, the most convenient way is to use either {\sf as.character} to
convert an {\sf editset} to text or {\sf as.data.frame} to convert it to a
2-column {\sf data.frame}. One can then use {\sf R}'s standard I/O
functionality to store edits as a structured textfile, or use one of the
database interfaces to send edits to a database. When edits are read into
{\sf R}, the function {\sf editset} is capable of converting textual edits
to an {\sf editset} object. See Table \ref{tabcoercion} for an overview of
coercion options.


\begin{table}
\begin{threeparttable}
\caption{Functions for reading and coercing (conditional) edits.}
\label{tabcoercion}
\begin{tabular}{lp{0.7\textwidth}}
\hline
Function        & Description\\
\hline
{\sf editset}      & read from {\sf character} or {\sf expression} vector.\\
{\sf editfile}     & read from free-form textfile\\
{\sf as.character} & convert editset to {\sf character} vector\\
{\sf as.data.frame}& convert editset to two-column {\sf data.frame}\\ 
\hline
\end{tabular}
\end{threeparttable}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Untangling condtional edits}
\label{sseditlist}
%
\begin{figure}[t]
<<fig=TRUE,echo=FALSE>>=
par(oma=c(0,0,0,0),mar=c(0,0,1.5,0))
set.seed(2)
plot(E)
@
\caption{A graph view of the edits of Figure \ref{figeditfile}, generated  with
{\sf plot(E)}.  Squares represent edits, circles represent variables. An edge
indicates that a variable occurs in an edit. The graph is displayed with the
help of the {\sf igraph} package of \cite{csardi:2006} .}
\label{figgraph}
\end{figure}
%
%
As mentioned in the introduction, edits can be interrelated because an edit 
can contain multiple variables and each variable can occur in multiple edits.
The function {\sf contains} returns a boolean matrix, indicating which variables
occur in each edit. The default {\sf plot} function has also been for objects
of class {\sf editset} (and {\sf editmatrix} and {\sf editarray}) to generate
a graphical display of this connectivity. Figure \ref{figgraph} shows the 
connectivity graph between the variables and edits of Figure \ref{figeditfile}.

The set of edits clearly consists of three independent blocks. The function
{\sf blocks} separates an {\sf editset} into its constituting independent edits
and returns a {\sf list} of independent {\sf editset} objects. The {\sf blocks}
function has been introduced before in \cite{jonge:2011} and \cite{loo:2011b}
for {\sf editmatrix} and {\sf editarray} objects respectively.

For conditional edits, there is a second way of separating them.
As an example, consider the following simple editset:
<<>>=
F <- editset(expression(
    if ( x > 0 ) y > 0,   # edit 1
    if ( x < 0 ) y < 0))  # edit 2
@
were we also demonstrate the use of expression vectors for defining edits.
Clearly, the valid areas are points in the first and third quadrant
of the Euclidian plane, excluding the $x$-axis, but including the $y$-axis. 

The valid area is clearly not convex, which has some computational
consequences, for example when we wish to compute projections on the $x$- or
$y$ axes, using Fourier-Motzkin elimination. The strategy we follow
here is to separate the solution space into convex subspaces. The
function {\sf disjunct} is designed to do just that.
<<>>=
disjunct(F)
@
The result of a call to {\sf disjunct} is an object of class {\sf editlist} (or
{\sf editenv}) which is a list of editsets which do not contain any conditional
edits anymore. However, the assumptions made to generate the separated editlist
are added as an extra property to each editset (printed as {\sf Conditions}).

The list is generated by generating all combinations of values of premises
occuring in conditional edits, and may therefore become large when many
conditional edits are present.  For example, in the example above, there are
two conditional edits. The following steps generate sets of edits describing
the two separate convex solution spaces.

\begin{enumerate}
\item Assume \true for the premise of edit 1 and \true for the premise
of edit 2. This yields the condition $x>0$ and $x<0$, which is a
contradiction and no edits are generated.
\item Assume \true for the premise of edit 1 and \false for the premise
of edit 2. This yields the conditions $x>0$ and $x\geq0$ and the edit
$y>0$ ({\em i.e.} the first quadrant).
\item Assume \false for the premise of edit 1 and \true for the premise
of edit 2. This yields the conditions $x\leq0$ and $x<0$ and the edit
$y<0$ ({\em i.e.} the third quadrant).
\item Assume \false for the premise of edit 1 and \false for the premise
of edit 2. This yields the condition $x\leq 0$ and $x\geq0$ and no conditions
on $y$.
\end{enumerate}
%
%
\begin{algorithm}[t]
\caption{Determine all feasible convex regions of an {\sf editset}.}
\label{algeditlist}
\begin{algorithmic}[1]
    \State $S\leftarrow \varnothing$
    \Procedure{disjunct}{$E$}
    \State $T\leftarrow \{t : t \textrm{ is a dummy variable of }E \}$
    \If {$T = \varnothing$}
        \State $S \leftarrow S\cup E$
    \Else
        \State Choose a $t$ from $T$
        \State $E\leftarrow \textrm{\sf substValue}(E,t,\true)$
        \If {$\textrm{\sf isFeasible}(E_{\sf num})\land \textrm{\sf isFeasible}(E_{\sf mixcat})$}
        \State $\textrm{\sc disjunct}(E)$
        \EndIf
        \State $E\leftarrow \textrm{\sf substValue}(E,t,\false)$
        \If {$\textrm{\sf isFeasible}(E_{\sf num})\land \textrm{\sf isFeasible}(E_{\sf mixcat})$}
        \State $\textrm{\sc disjunct}(E)$
        \EndIf
    \EndIf
    \EndProcedure
\end{algorithmic}
\end{algorithm}

The above example is generalized by the simple recursive procedure shown in
Algorithm \ref{algeditlist}. The algorithm runs depth-first through a binary
tree, generating all possible assumtions about the premises in the conditional
edits. The tree is pruned whenever an inconsistent set of assumptions is made,
so no spurious edit sets are generated. The procedure uses the functions {\sf
isFeasible} on objects of class {\sf editmatrix} and {\sf editarray} which have
been discussed in \cite{jonge:2011} and \cite{loo:2011b} respectively.  The
{\sf substValue} function for objects of class {\sf editset} will be discussed
in Section \ref{sssubstitution}. For here, just note that substituting a value
for a dummy variable [see also Eq. \ref{eqdummy}] is equivalent to assuming a
value for edits in the premise or consequent in a conditional edit.

\begin{figure}
<<fig=true,echo=false>>=
v <- disjunct(E)
par(oma=c(0,0,0,0),mar=c(0,0,1.5,0),mfrow=c(2,2),pty='m')
for ( i in 1:length(v) ){
    set.seed(1)
    plot(
        v[[i]],
        main=paste(as.character(editrules:::condition(v[[i]])),collapse=', ')
    )
}
@
\caption{Connectivity graphs of the disjunct edit sets
generated from the edits of Figure \ref{figeditfile}. There are no paths from
numerical variables ($x$, $y$, $z$, $u$, $v$, $w$) to categorical 
variables ($A$, $B$, $C$, $D$) anymore. The titles of the subplots indicate
the conditions for each editset.}
\label{figdisjunct}
\end{figure}
%
%
As an example of how {\sf disjunct} separates numerical from categorical
variables, the four editsets, resulting from passing the edits of Figure
\ref{figeditfile} to {\sf disjunct} are plotted in Figure \ref{figdisjunct}.
The original editset has two dummy variables, corresponding to $x>0$ and $y>0$,
yielding four disjunct spaces. Note that contrary to Figure \ref{figgraph},
there are no paths connecting numerical variables ($x$,$y$,$z$,$u$,$v$,$w$) to
categorical variables ($A$, $B$, $C$, $D$) anymore.
%
\begin{table}[t]
\caption{Edit separation functions}
\label{tabseparators}
\begin{tabular}{lp{0.8\textwidth}}
\hline
Function & Description\\
\hline
{\sf blocks}   & Splits an editset in smaller editsets not sharing any variables.\\
{\sf disjunct} & Splits an editset in disjunct sets, not containing conditional edits.\\
{\sf separate} & Uses {\sf blocks}, simplifies and calls {\sf disjunct} where possible.\\
\hline
\end{tabular}
\end{table}

The {\sf editlist} ({\sf editenv}) class is of importance, especially since the
{\sf eliminate} function uses and returns an {\sf editlist} ({\sf editenv}),
regardless of whether one passes an {\sf editset} or an {\sf editlist} ({\sf
editenv}). The elimination function for editsets is further discussed in Section
\ref{sselimination}

Finally, we note that there is one function that combines the blocking 
functionality with the disjunct functionality. Function {\sf separate}
blocks each an editset based on variable occurrence and simplifies
the blocks to objects of class {\sf editmatrix} or {\sf editarray}
where possible. After this, the remaining {\sf editset} objects are
split into an {\sf editlist} using {\sf disjunct}. The result is
returned as an {\sf R} {\sf list}. Table \ref{tabseparators} summarizes
the edit separation functions.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Edit checking, obvious redundancy and (in)feasibility}
Data can be checked against edits in an editset with the {\sf violatedEdits}
function. This function accepts an {\sf editset} and a {\sf data.frame} and
returns a logical array (of class {\sf violatedEdits}) where each row and
column indicates which record violates what edit. A {\sf summary} and {\sf
plot} method is available for {\sf violatedEdits} objects so users can get a
quick overview of edit violation frequencies. Internally, the {\sf
violatedEdits} method for editsets works by coercing the edits to logical {\sf
character} expression and using {\sf R}'s evaluation functionality to parse and
evaluate these expressions in the context of the {\sf data.frame}. 

An edit in an {\sf editset} is obviously redundant when it is the duplicate of
another edit or when it has an easily recognizable form such as $0 < 1$. Such
redundancies may arise after edit manipulations (value substitution, variable
elimination).  The {\sf isObviouslyRedundant} method for {\sf editset} returns
a logical vector indicating which edit in an editset is redundant (\true) or
not (\false). For an {\sf editlist} ({\sf editenv}) a list of boolean vectors
is returned. For a detailed description of detecting obvious redundancies in
numerical or categorical edits, refer to \cite{jonge:2011} and
\cite{loo:2011b}.

The {\sf S3} methods of {\sf isObviouslyInfeasible} for objects of class {\sf
editset} and {\sf editlist} work the methods previously implemented for objects
of class {\sf editarray} and {\sf editmatrix}. For an {\sf editset}, {\sf
isObviouslyInfeasible} returns \true if either the {\bf num} or the {\bf
mixcat} [See Eq. \eqref{eqeditset}] part contains an obvious contradiction. For
objects of class {\bf editlist} or {\sf editenv} a vector of logicals is
returned. Note that the presence of an obvious contradiction is sufficient, but
not necessary for a set of edits to be infeasible. To prove (in)feasibility,
one needs to call {\sf isFeasible}, which is usually a much more expensive
calculation.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Manipulation of conditional edits}
\label{smanipulation}
The two basic operations on any set of restrictions, either numerical,
categorical, or mixed/conditional consist of value substitution and variable
elimination. Methods for the pure numerical and pure categorical situations are
fairly straightforward and have been implemented in the {\sf editrules} package
before. Operations on conditional edits require a bit more care, which will
be detailed in the next two subsections.

\subsection{Value substitution}
\label{sssubstitution}
Recall that conditional edits in an editset are stored as a combination of
categorical edits with dummy variables ($E_{\sf mixnum}$), referring to linear
edits in $E_{\sf mixnum}$. Purely numerical edits are stored in a seperate
object called $E_{\sf num}$.
To substitute a value in an editset, we need to distinguis several cases.
If a variable occurs in $E_{\sf num}$, but not in ${E_{\sf mixnum}}$ the
{\sf substValue} method for {\sf editarray} is used on $E_{\sf num}$, as
described in \cite{jonge:2011}. For a categorical variable, the procedure
for substitition in an {\sf editarray} is followed for $E_{\sf mixcat}$,
as described in \cite{loo:2011b}. If the substituted variable is a numerical
variable, occuring in $E_{\sf mixnum}$ (and possibly $E_{\sf num}$), the following
steps must be performed.
%
\begin{enumerate}
\item If the variable occurs in $E_{\sf num}$ substitute its value there.
\item Substitute the variable in $E_{\sf mixnum}$.
\item If any edits in $E_{\sf mixnum}$ have become obviously redundant ({\em e.g.} $0 < 1$) or
obvious contradictions ({\em e.g.} $1 < 0$), substitute respectively \true or \false for
the corresponding dummy variables in $E_{\sf mixcat}$.
\item Remove all edits of the form 
\begin{displaymath}
\textrm{\sf if } \true \textrm{ \sf then  } t,
\end{displaymath}
from $E_{\sf mixcat}$. (Recall that $t$ is a dummy variable, see Eqs.\ \eqref{eqdummy}-\eqref{eqdummyedit2}).
\item If the dummy variable $t$ does not occur anywhere $E_{\sf mixcat}$ anymore, move the 
corresponding linear inequality from $E_{\sf mixnum}$ to $E_{\sf num}$.
\item Remove all edits of the form
\begin{displaymath}
\textrm{\sf if } \false \textrm{ \sf then  } t
\end{displaymath}
\end{enumerate}
%
%
Besides the above procedure, the {\sf substValue} function performs some simplifications
on $E_{\sf mixnum}$ and $E_{\sf mixcat}$.

As an example, consider the code below.
<<>>=
F <- editset(expression(
x + y == z,
if ( x > 0 ) y > 0))
substValue(F,"x",3)
@
Here, substituting $x=3$, yields $\textrm{\sf  if } \true \textrm{ \sf  then } y>0$, so the 
consequent $y>0$ may be added the numerical edits (here: $x+y=z$). 
On the other hand, substituting $x = -3$ gives $\textrm{\sf  if } -3 > 0 \textrm{ \sf  then } y>0$,
yielding a false premise and the conditional edit can be deleted:
<<>>=
substValue(F,"x",-3)
@





\subsection{Variable elimination and satisfiability}
\label{sselimination}
<<>>=
E <- editset(expression(
    if ( x >= 0 ) y >= 0,
    if ( x >= 0 ) x <= y,
    if ( x < 0 ) y < 0,
    if ( x < 0 ) x + y < 2
))
E
@



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Error Localization on mixed data}
\label{serrorlocalization}



\section{Conclusions}
\label{sconclusions}

\clearpage
\bibliographystyle{chicago}
\bibliography{editrules}

\clearpage
\addcontentsline{toc}{section}{Index}
\printindex



\end{document}


