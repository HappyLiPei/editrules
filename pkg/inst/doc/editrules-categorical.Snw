%\VignetteIndexEntry{Categorical edit manipulation and error localization with the editrules package}
\documentclass[11pt, fleqn, a4paper]{article}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb}
\usepackage{threeparttable}
\usepackage{natbib}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}
\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\Lor}{\lor}
\DeclareMathOperator*{\Land}{\land}
\DeclareMathOperator{\res}{\mathfrak{R}}
\newcommand{\rhomap}{\xrightarrow{\rho}}

\usepackage{float}
 
\floatstyle{boxed}
\newfloat{Rcode}{t}{rco}
\floatname{Rcode}{Figure}
 


% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}
\hyphenation{time-stamp}

<<echo=false>>=
library(editrules)
path <- "../../../develop/categorical"
source(file.path(path,"editarray.R"))
source(file.path(path,"categorical.R"))
source(file.path(path,"reduceCat.R"))
parseEdits <- editrules:::parseEdits
@

\title{Manipulation of categorical and mixed data edits and error localization with the {\tt editrules} package\\
{\small package version \Sexpr{packageVersion("editrules")}}}
\author{Mark van der Loo and Edwin de Jonge}
\begin{document}
\maketitle
\begin{abstract}
{\em This vignette is far from finished. Version 2.0 fo the package will have
the full vignette.}
\end{abstract}

\newpage
\tableofcontents
\newpage

\section{Introduction}


\section{Defining and checking categorical constraints}
We spend some time to define the boolean representation, since it eventually allow for an elegant
elimination method.
\subsection{The {\tt editarray} object}
A categorical record ${\bf v}$ is a combination of values from the
cartesian product space
\begin{equation}
    D = D_1\times D_2\times\ldots\times D_n,
\end{equation}
where each $D_k$ is a finite set of $d_k$ categories. The total number of
categories is $d = \sum_{k=1}^n d_k$.
Categorical records can be represented as  a boolean vector. A boolean
vector of dimension $d$ is an element of the boolean algebra 
\begin{equation}
\mathbb{B}^{d}=\left(\{0,1\}^{d},\land,\lor,\lnot\right),
\end{equation}
where 0 and 1 have the usual interpretations {\sc false} and {\sc true} and the
logical operators work elementwise on their operands. To represent a record
${\bf v}$, assign to every category $i$ in $D_k$ a unique standard 
basisvector $\vec{\delta}_k(i)$ of $\mathbb{B}^{d_k}$. 
The boolean representation $\rho({\bf v})$ of the full record reads
%
\begin{equation}
    {\bf v} \xrightarrow{\rho} \vec{\delta}_{1}(v_1)\oplus\vec{\delta}_{2}(v_2)\oplus\ldots\oplus\vec{\delta}_n(v_n).
\end{equation}
An edit $e$ is a subset of $D$, which can be written as the cartesian product
\begin{equation}
    e = {\bf e}_1\times{\bf e}_2\ldots\times{\bf e}_n,
\end{equation}
where each ${\bf e}_k\subseteq D_k$.  The interpretation of an edit is that if
a record ${\bf v}\in {\bf e}$, then ${\bf v}$ is considered invalid. Since every
category $i$ of $D_k$ is mapped to a unique basis vector $\vec{\delta}_k(i)$,  the
subset ${\bf a}$ has a boolean representation given by
\begin{eqnarray}
    e &\xrightarrow{\rho}&
    \Lor_{i\in{\bf e}_1}\vec{\delta}_1(i)\oplus
    \Lor_{i\in{\bf e}_2}\vec{\delta}_2(i)\oplus\ldots
    \oplus\Lor_{i\in{\bf e}_k}\vec{\delta}_n(i).
\end{eqnarray}
This gives yields a fast computational way for determining record validity, since
\begin{equation}
    {\bf v}\in{e}\Leftrightarrow \sum_{j=1}^d(\rho({\bf v})\land\rho({ e}))_j = n,
    \label{eqCheckEdit}
\end{equation}
where the sum is over the coefficients of $\rho({\bf v})\land\rho({ e})$, interpreted
as numbers. We say that a record {\em fails} an edit when it satisfies Eq.\ \eqref{eqCheckEdit}.

In the {\tt editrules} package, a set of categorical edits is represented as an {\tt editarray}
object. Formally, we denote an edit array $E$ as
\begin{equation}
    E = \langle {\bf A}\rangle\textrm{, with }{\bf A}\in\{0,1\}^{m\times d}.
    \label{eqEditarray}
\end{equation}
Here, each row of ${\bf A}$ contains the boolean representation of one edit. The brackets
are used to indicate a combination of objects. The {\tt editarray} is the central object for
computing with catgegorical edits, just like the {\tt editmatrix} is the central object for
computations with linear edits.
 
%
\begin{Rcode}
<<keep.source=true>>=
editarray(c(
    "gender %in% c('male','female')",
    "pregnant %in% c('yes','no')",
    "if (gender == 'male') pregnant == 'no'"
    )
)
@
\caption{Defining a simple {\tt editarray} with the {\tt editarray} function. 
Column heads of the array are abbreviated versions of variable names and categories
seperated by a colon (by default). When printed to screen, a {\tt character} version
of the edits is shown as well, for readability.
}
\label{Reditarray}
\end{Rcode}
%

It is both tedious and error prone to define and maintain an editarray by hand. In practice,
categorical edits are usually stated verbosely, such as: ``if the gender is male, then pregnant must be false'',
or ``if you are under-aged, you cannot be married''. To facilitate the definition of edit arrays, {\tt editrules}
is equipped with a parser, which takes R-statements in {\tt character} format, and translates them to
an {\tt editarray}.

Figure \ref{Reditarray} shows a simple example of defining an editmatrix with
the editrules package.  The first two edits in Figure \ref{Reditarray} define
the data model. The {\tt editarray} function derives the datamodel based on the
variable names and categories it finds in the edits, whether they are
univariate (defining domains) of multivariate. This means that if all possible
variables and categories are mentioned in the multivariate edits, the correct
datamodel will be derived as well. It is important to note that most functions
working with categorical edits, assume that the full datamodel is represented
in the columns of an {\tt editarray}. The function {\tt datamodel} accepts an
edit array as input and returns an overview of variables and their categories,
allowing for inspection.

When printed to the screen, the boolean array is shown with column heads of the form
\begin{quote}
{\tt <variable><separator><category>}, 
\end{quote}
where both variable names and categories are abbreviated for readability, and
the standard separator is a colon ({\tt :}). The separator may not occur as a
symbol in either variable or category name, and its value can be determined by
passing a custom {\tt sep} argument to {\tt editarray}.

Internally, {\tt editarray} uses the {\sf R} internal {\tt parse} function to
transform the {\tt character} expressions to a parse tree, which is
subsequently traversed recursively to derive the entries of the editmatrix. The
opposite is also possible. The {\sf R} internal function {\tt as.character} has
been overloaded to derive a {\tt character} representation from a boolean
representation. When printed to the screen, both the boolean and textual
representation are shown.

The character expressions that can be read by {\tt editarray}, such as
\begin{quote}
\verb+"if ( gender == 'male' ) pregnant = 'no'"+ 
\end{quote}
follows standard {\sf R} syntax, which should be already familliar to the
reader. Note that double quotes are used to enclose the whole string, while
single quotes are used for category names. Table \ref{tabOperators} shows
which operators and functions can be used to specify categorical edit rules.
%
\begin{table}
\begin{threeparttable}
\caption{Functions and operators that may be used to define edits with {\tt editarray} }
\label{tabOperators}
\begin{tabular}{ll}
\hline
Operator & Description\\
\hline
{\tt \%in\%} & Set membership$^*$  \\
{\tt ==}     & Equality$^*$ \\
{\tt if( <condition> ) <expression> } & conditional statement\\
{\tt c(\verb"'"<cat1>\verb"'",\verb"'"<cat2>\verb"'",...)} & categories, {\tt character} or {\tt logical}\\
{\tt \&\&}    & logical {\sc and}\\
{\tt ||}      & logical {\sc or}\\
{\tt !}       & logical {\sc not}\\
\hline
\end{tabular}
$^*${\small Right-hand side is evaluated.}
\end{threeparttable}
\end{table}
%
%
Categories may be litaral characters, or booleans.  It is worth noting that
expressions on the right hand side of the {\tt \%in\%}  and {\tt ==} operators
are evaluated. One useful application of this is that the categories, or data
model can be defined outside of the edits:
%
<<keep.source=true>>=
xval <- letters[1:4]
yval <- c(TRUE,FALSE)
editarray(c( "x %in% xval","y %in% yval","if ( x %in% c('a','b') ) !y "))
@
%
The above example also illustrates the use of boolean categories.



\subsection{Basic manipulations and edit checking}

\begin{table}
\begin{threeparttable}
\caption{Basic functions for objects of class {\tt editarray}. Only mandatory
arguments are shown, refer to the built-in documentation for optional
arguments.}
\begin{tabular}{ll}
\hline
Function        & description \\
\hline
{\tt datamodel(E)}      & get datamodel \\
{\tt getArr}            & get array ${\bf A}$\\
{\tt as.data.frame(E)}  & coerce to {\tt data.frame}\\
{\tt as.character(E)}   & coerce to {\tt character} vector\\
{\tt violatedEdits(E,x)}& check which edits are violated by {\tt x}\\
\hline
\end{tabular}
\end{threeparttable}
\end{table}


\subsection{Obvious redundancy and infeasibility}

\section{Manipulation of categorical restrictions}
Write
\begin{equation}
    \rho(e) ={\bf a} = {\bf a}_1\oplus{\bf a}_2\oplus\ldots\oplus{\bf a}_n,
\end{equation}
with $e\subseteq D$ and ${\bf a}\in \oplus_{k=1}^n\mathbb{B}^{d_k}$.
Suppose $e_1$ and $e_2$ are edits, with boolean representations ${\bf a}$ and ${\bf b}$ respectively.
We define the {\em resolution operator} $\res_j$ as follows:
\begin{eqnarray}
    {\bf a} \res_j {\bf b} = (a_1\land b_1,\ldots,a_{j-1}\land b_{j-1},a_{j}\lor b_{j},a_{j+1}\land b_{j+1},\ldots,a_d\land b_d). 
\end{eqnarray}
Observe that if a record ${\bf v}\in {\bf a}\res_j{\bf b}$, it must hold that
${\bf v}\in e_1$ and/or ${\bf v}\in e_2$.  The converse is also true: If ${\bf
v}\in e_1$ or $e_2$, then it must be in $e_1\res_j e_2$.  The operator is
called resolution operator since its action strongly resembles a resolution
operation from formal logic.  If $a_j= \lnot b_j$, the operator ``resolves'' or
eliminates one of the categories $j\in D$. If $a_j=b_j$, the resulting edit is
the intersection of the original edits.


Given the boolean vectors {\bf a}, {\bf b} and {\bf c} in $\mathbb{B}^d$. It is not difficult to show that the resolution
operator has the following properties 
\begin{equation}
\begin{array}{ll}
\textrm{symmetry:}  &{\bf a}\res_j{\bf b} = {\bf b} \res_j {\bf a} \\
\textrm{associativity:}& ({\bf a}\res_j{\bf b})\res_j {\bf c} = {\bf a}\res_j({\bf b}\res_j {\bf c})\\
\textrm{idempotency:} &{\bf a}\res_j {\bf a} = {\bf a}.
\end{array}
\end{equation}
The following distributive property also holds
\begin{equation}
\begin{array}{ll}
\textrm{distributivity:}& ({\bf a}\res_i{\bf b})\res_j{\bf c} = ({\bf a}\res_j{\bf c})\res_i({\bf b}\res_j{\bf c}).
\end{array}
\end{equation}




\bibliographystyle{chicago}
\bibliography{editrules}

\end{document}
