%\VignetteIndexEntry{Categorical edit manipulation and error localization with the editrules package}
\documentclass[11pt, fleqn, a4paper]{article}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{threeparttable}
\usepackage{natbib}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}
\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\Lor}{\lor}
\DeclareMathOperator*{\Land}{\land}
\DeclareMathOperator{\res}{\mathfrak{R}}
\newcommand{\rhomap}{\xrightarrow{\rho}}
\newcommand{\rows}{\textrm{rows}}
\newcommand{\columns}{\textrm{columns}}
\newcommand{\ind}{\textrm{\bf ind}}
\newcommand{\true}{\textrm{\sc true}}
\newcommand{\false}{\textrm{\sc false}}

\newtheorem{theorem}{Theorem}

\usepackage{float}
 
\floatstyle{boxed}
\newfloat{Rcode}{t}{rco}
\floatname{Rcode}{Figure}



% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}
\hyphenation{time-stamp}

<<echo=false>>=
library(editrules)
@

\title{Manipulation of categorical data edits and error localization with the {\sf editrules} package\\
{\small package version \Sexpr{packageVersion("editrules")}}}
\author{Mark van der Loo and Edwin de Jonge}
\begin{document}
\maketitle
\begin{abstract}
{\em This vignette is far from finished. Version 2.0 fo the package will have
the full vignette. At the moment, functionality for treating categorical data has alpha status and is not public yet.
Refer to the accompanying paper \cite{jonge:2011} for manipulation of linear edits.
}
\end{abstract}

\newpage
\tableofcontents
\newpage


\section{Introduction}
The value domain of categorical data records is usually limited by domain rules
interrelating these variables.  The simplest examples are cases where the value
of one variable excludes values of another variable. For example: if the age
class of a person is ``child'', then (by law) the marital status cannot be
``married''. In survey or administrative data, violations of such rules are
frequently encountered. Resolving such violations is an important step prior to 
data analysis and estimation.

A categorical data record $\bf v$ with $n$ variables may be defined as an
element of the cartesian product space $D$:
\begin{equation}
D = D_1\times D_2\times\ldots\times D_n,
\end{equation}
where each $D_k$ is a finite set of $d_k$ possible categories for the $i$th
variable.  Each restriction $e$ is a subset of $D$ and we say that that {\em if
${\bf v}\in e$ then $\bf v$ violates $e$}. Conversely, when ${\bf v}\not\in e$
we say that ${\bf v}$ {\em satisfies} $e$. In data editing literature, such
rules are referred to as {\em edit rules} or {\em edits}, in short. In the
context of contingency tables they are referred to as {\em structural zeros}
since each rule implies one or more cells in the $d_1\times d_2\times\ldots
\times d_n$ contingency table must be zero. A record is {\em  valid} if it satisfies
every edit imposed on $D$.


Large, complex surveys may consist of hundreds of interrelated rules and
variables, which impedes resolution of edit violations and renders manual
manipulation infeasible. The {\sf R} package {\sf editrules}  offers functionality to
define, manipulate and maintain sets of edit rules with relative ease. It also
implements error localization functionality based on the generalized principle
of \citep{fellegi:1976}, which states that one should find the smallest
(weighted) number of variables whose values can be adapted such that all edits
can be satisfied. Fellegi and Holt's principle should be considered as the last
resort of data editing. It is useful in situations where a record violates one
or more edits and there is no information about the cause of the error. In
certain cases, the cause of error can be estimated with near certainty, for
example in the case of typing errors in numerical data.  We refer the reader to
\cite{scholtus:2008,scholtus:2009} and \cite{loo:2011} for such cases.

In the remainder of this paper the representation and manipulation of edits is
discussed and algorithms are given in pseudocode. Also, coded examples are
given, al of which can be executed after loading the editrules package.















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Defining and checking categorical constraints}
In the next section we describe the representation of edits and records as
implemented in the {\sf editrules} package. Readers not interested in the
underlying principles may skip Section \ref{sectBoolrep}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Boolean representation of edits and records}
\label{sectBoolrep}
Categorical records may be represented as  a vector of boolean values. A
boolean vector of dimension $d$ is an element of the boolean algebra 
\begin{equation}
\mathbb{B}^{d}=\left(\{0,1\}^{d},\land,\lor,\lnot\right),
\end{equation}
where 0 and 1 have the usual interpretations {\sc false} and {\sc true} and the
logical operators work elementwise on their operands. To facilitate the
discussion we will also allow the standard arithmetic operations addition and
subtraction on boolean vectors (this is also consistent with the way {\sf R}
handles vectors of class {\sf logical}). 

To represent a record ${\bf v}=(v_1,v_2,\ldots,v_n)$, assign to every category
$i$ in $D_k$ a unique standard basisvector $\vec{\delta}_k(i)$ of
$\mathbb{B}^{d_k}$.  The boolean representation $\rho({\bf v})$ of the full
record is the direct sum
%
\begin{equation}
    {\bf v} \xrightarrow{\rho} \vec{\delta}_{1}(v_1)\oplus\vec{\delta}_{2}(v_2)\oplus\ldots\oplus\vec{\delta}_n(v_n).
\end{equation}
The diminsion $d$ of $\rho({\bf v})$ is given by the total number of categories of all variables
\begin{equation}
d = \sum_{k=1}^n d_k.
\end{equation}
When each record in a dataset is represented this way, summing the vectors
yields the $d$-dimensional vecorized representation of the $d_1\times
d_2\times\ldots\times d_n$ contingency table of the dataset. This is sometimes
called the complete disjunctive table. 

An edit $e$ is a subset of $D$ which can be written as the cartesian product
\begin{equation}
    e = A_1\times A_2\ldots\times A_n\textrm{, where } A_{k}\subseteq D_k,\: k=1,2,\ldots n. 
    \label{eqDefEdit}
\end{equation}
The interpretation of an edit is that if a record ${\bf v}\in e$, then ${\bf
v}$ is considered invalid.  A variable $v_k$ is {\em involved} in an edit if
$A_k\subset D_k$.  Conversely, we say that $e$ {\em involves} $v_k$ if $v_k$ is
involved in $e$. A variable $v_k$ for which $A_k=D_k$ is not involved in $e$.
Since every category $i$ of $D_k$ is mapped to a unique basis vector
$\vec{\delta}_k(i)$,  edits have a boolean representation $\rho(e)$, given by
\begin{eqnarray}
    e &\xrightarrow{\rho}&
    \Lor_{i\in A_1}\vec{\delta}_1(i)\oplus
    \Lor_{i\in A_2}\vec{\delta}_2(i)\oplus\ldots
    \oplus\Lor_{i\in A_n}\vec{\delta}_n(i),
\end{eqnarray}
which may simply be written as
\begin{equation}
    \rho(e) = {\bf a}_1\oplus{\bf a}_2\oplus\ldots\oplus{\bf a}_n={\bf a} .
\label{EqRhoE}
\end{equation}
A simple example is given in Figure \ref{Reditarray}. It is easy to check that
an edit contains variable $k$  if and only if the inner product ${\bf 1}_{d_k}\cdot{\bf a}_k<d_k$,
where ${\bf 1}_{d_k}$ is a $d_k$ vector of ones.

A record ${\bf v}$
violates an edit if $v_k\in A_k$, $k=1,2,\ldots n$.  In the boolean
representation this can be written as a condition on the standard inner product
between the boolean representation of a record and an edit:
\begin{equation}
\sum_{k=1}^n \vec{\delta}_k(v_k)\cdot{\bf a}_k =\rho({\bf v})\cdot{\bf a} =  n.
\label{eqViolatedEdits}
\end{equation}

Suppose that $E$ is a set of edits of the form \eqref{eqDefEdit}. It is not difficult to verify that an 
edit $e\in E$ is redundant if
%
\begin{eqnarray}
    \label{eqRedundancy1}
    A_k &=&\varnothing,\textrm{ for any } k\in1,2,\ldots,n\\
    \lefteqn{\textrm{or}}\nonumber\\
    \label{eqRedundancy2}
    e   &\subseteq& e'\textrm{ with  } e'\in E.
\end{eqnarray}
In \eqref{eqRedundancy1}, $e$ is redundant since it cannot contain any records.
It can be tested by checking if any ${\bf 1}_{d_k}\cdot{\bf a}_k=0$.  In the case
of \eqref{eqRedundancy2}, $e$ is redundant because any edit violating $e$ also
violates $e'$. Using $\rho(e)={\bf a}$ and $\rho(e')={\bf a}'$, this can be
tested by checking if ${\bf a}\land{\bf a}'={\bf a}$ or equivalently if ${\bf
a}\lor {\bf a}'={\bf a}'$.

In the {\sf editrules} the boolean representation is mainly used to store edits
and to manipulate them with methods like variable substitution and elimination.
Data records can be stored in {\sf data.frame} objects, as usual. 

\subsection{The {\sf editarray} object}
In the {\sf editrules} package, a set of categorical edits is represented as an {\sf editarray}
object. Formally, we denote an edit array $E$ for $n$ categorical variables and $m$ edits as
(brackets indicate a combination of objects)  
\begin{equation}
    E = \langle {\bf A},{\bf ind}\rangle\textrm{, with }{\bf A}\in\{0,1\}^{m\times d}\textrm{ and }
    d = \sum_{k=1}^n d_k,
    \label{eqEditarray}
\end{equation}
Each row of ${\bf A}$ contains the boolean representation of one edit, and the
$d_k$ denote the number of categories of each variable.  The object {\bf ind}
is a nested {\sf list} which relates columns of {\bf A} to variable names and
categories.  Labeling variables with $k\in1,2,\ldots,n$ and category values
with $i\in 1,2,\ldots,d_k$, we use the following notations:
\begin{eqnarray}
    {\bf ind}(k,i) &=& \sum_{j< k }d_j + i\\
    {\bf ind}(k)   &=& \{{\bf ind}(k,i)\,|\, i\in D_k\}.
\end{eqnarray}
So $\ind(k,i)$ is the column index in {\bf A} for variable $k$ and category $i$
and $\ind(k)$ is the set of column indices corresponding to the categories of
variable $k$.  The {\sf editarray} is the central object for computing with
catgegorical edits, just like the {\sf editmatrix} is the central object for
computations with linear edits.

It is both tedious and error prone to define and maintain an editarray by hand.
In practice, categorical edits are usually stated verbosely, such as: ``a male
subject cannot be pregnant'', or ``an under-aged subject cannot be married''.
To facilitate the definition of edit arrays, {\sf editrules} is equipped with a
parser, which takes R-statements in {\sf character} format, and translates them
to an {\sf editarray}.

%
\begin{Rcode}
<<keep.source=true>>=
E <- editarray(c(
    "gender %in% c('male','female')",
    "pregnant %in% c('yes','no')",
    "if (gender == 'male') pregnant == 'no'"
    )
)
E
datamodel(E)
@
\caption{Defining a simple {\sf editarray} with the {\sf editarray} function.
The array is printed with abbreviated column heads, which themselves consist of
variable names and categories seperated by a colon (by default). When printed
to screen, a {\sf character} version of the edits is shown as well, for
readability.
}
\label{Reditarray}
\end{Rcode}
%
Figure \ref{Reditarray} shows a simple example of defining an editmatrix with
the editrules package.  The first two edits in Figure \ref{Reditarray} define
the data model. The {\sf editarray} function derives the datamodel based on the
variable names and categories it finds in the edits, whether they are
univariate (defining domains) of multivariate. This means that if all possible
variables and categories are mentioned in the multivariate edits, the correct
datamodel will be derived as well. It is important to note that most functions
working on categorical edits assume that the full datamodel is represented
in the columns of an {\sf editarray}. The function {\sf datamodel} accepts an
edit array as input and returns an overview of variables and their categories
for easy inspection.

When printed to the screen, the boolean array is shown with column heads of the form
\begin{quote}
{\sf <variable><separator><category>}, 
\end{quote}
where both variable names and categories are abbreviated for readability, and
the standard separator is a colon ({\sf :}). The separator may not occur as a
symbol in either variable or category name, and its value can be determined by
passing a custom {\sf sep} argument to {\sf editarray}.

Internally, {\sf editarray} uses the {\sf R} internal {\sf parse} function to
transform the {\sf character} expressions to a parse tree, which is
subsequently traversed recursively to derive the entries of the editmatrix. The
opposite is also possible. The {\sf R} internal function {\sf as.character} has
been overloaded to derive a {\sf character} representation from a boolean
representation. When printed to the screen, both the boolean and textual
representation are shown.

The character expressions that can be read by {\sf editarray}, such as
\begin{quote}
\verb+"if ( gender == 'male' ) pregnant = 'no'"+ 
\end{quote}
follows standard {\sf R} syntax, which should be already familliar to the
reader. Note that double quotes are used to enclose the whole string, while
single quotes are used for category names. Table \ref{tabOperators} shows
which operators and functions can be used to specify categorical edit rules.



Categories may be litaral characters, or booleans.  It is worth noting that
expressions on the right hand side of the {\sf \%in\%}  and {\sf ==} operators
are evaluated. One useful application of this is that the categories, or data
model can be defined outside of the edits:
%
<<keep.source=true>>=
xval <- letters[1:4]
yval <- c(TRUE,FALSE)
editarray(c( "x %in% xval","y %in% yval","if ( x %in% c('a','b') ) !y "))
@
%
The above example also illustrates the use of boolean categories.



\begin{table}
\begin{threeparttable}
\caption{Functions and operators that may be used to define edits with {\sf editarray} }
\label{tabOperators}
\begin{tabular}{ll}
\hline
Operator & Description\\
\hline
{\sf \%in\%} & Set membership$^*$  \\
{\sf ==}     & Equality$^*$ \\
{\sf if( <condition> ) <expression> } & conditional statement\\
{\sf c(\verb"'"<cat1>\verb"'",\verb"'"<cat2>\verb"'",...)} & categories, {\sf character} or {\sf logical}\\
{\sf \&\&}    & logical {\sc and}\\
{\sf ||}      & logical {\sc or}\\
{\sf !}       & logical {\sc not}\\
\hline
\end{tabular}
$^*${\small Right-hand side is evaluated.}
\end{threeparttable}
\end{table}
%

\subsection{Coercion, checking, redundancy and infeasibility}
Table \ref{tabBasicfunctions} lists basic functions of {\sf editarray} objects.
The {\sf datamodel} function retrieves the variables and categories in an edit
array, and returns them as a two-column {\sf data.frame}. With {\sf
as.data.frame} or {\sf as.character} one can coerce an editarray so that it can
be written to a file or database. Character coercion is used when edeits are
printed to the screen. Optionally, coercing the datamodel to character form can
be switched off. The result of {\sf as.data.frame} version contains columns
with edit names, a character representaition of the edits and a column for
remarks.

The function {\sf violatedEdits} takes an {\sf editarray} and a {\sf
data.frame} as input and returns a logical matrix indicating which record
(rows) violate which edits (columns). It works by parsing the {\sf editarray}
to R-expressions and evaluating them within the {\sf data.frame} environment.
By default, the records are checked against the data model. This can be turned
off by providing the optional argument {\sf datamodel=FALSE}. 


\begin{table}
\begin{threeparttable}
\caption{Basic functions for objects of class {\sf editarray}. Only mandatory
arguments are shown, refer to the built-in documentation for optional
arguments.}
\label{tabBasicfunctions}
\begin{tabular}{ll}
\hline
Function        & description \\
\hline
{\sf datamodel(E)}           & get datamodel \\
{\sf getVars(E)}             & get a list of variables\\
{\sf as.data.frame(E)}       & coerce edits to {\sf data.frame}\\
{\sf contains(E)}            & which edits contains which variable\\
{\sf as.character(E)}        & coerce edits to {\sf character} vector\\
{\sf violatedEdits(E,x)}     & check which edits are violated by {\sf x}\\
{\sf isObviouslyRedundant(E)}& find redundancies [Eq.\ \eqref{eqRedundancy1}], duplicates\\
{\sf duplicated(E)}          & find duplicate edits\\
{\sf isSubset(E)}            & find edits, subset of another edit [Eq.\ \eqref{eqRedundancy2}]\\
{\sf isObviouslyInfeasible(E)}& detect contradictions\\ 
{\sf substValue(E,var,value)} & substitute a value\\
\hline
\end{tabular}
\end{threeparttable}
\end{table}


When manipulating edit sets, redundant edits of the form in Eq.\ \eqref{eqRedundancy1}
may arise. Such redundancies can be detected in the boolean representation with
{\sf isObviouslyRedundant}. By default, this funciton also checks for duplicate edits,
but this may be turned off. The function {\sf duplicated} is overloaded from the standard
{\sf R} function and the function {\sf isSubset} detects which edits are a subset or
duplicate of another one.

Manipulations may also lead to edits of the form $e=D$, in which case every possible
record is invalid, and the editarray has become impossible to satisfy. The function
{\sf isObviouslyInfeasible} detects whether any such edits are present. They can be 
detected by checking if $\sum_{j=1}^d\rho(e)_j=d$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SECTION 2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Manipulation of categorical restrictions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Value substitution}
If we assume that in a record, one of the variables (say, $k$) takes a certain value
(say, $i$), we may substitute that value in the edit rules. In the boolean representation
this amounts to removing all edits which exclude that value, since the record cannot 
fall in that edit anymore. What remains, are relations between all other variables, 
except the one that was substituted. In the boolean representation, a variable is
removed by setting all its categories to \true. Pseudocode is given in Algorithm \ref{substValue}.
%
\begin{algorithm}[t]
\caption{{\sc substValue($E$,$k$,$v$)}}
\label{substValue}
\begin{algorithmic}
    \Require an {\sf editarray} $E=\langle{\bf A},{\bf ind}\rangle$, a variable index $k$ and a value $v$
    \State $i \leftarrow \ind(k,v)$
    \State ${\bf A}\leftarrow {\bf A}\backslash\{{\bf a}\in\rows({\bf A})\,|\,a_i=\false\}$\Comment{Remove rows not involving $v$ }
    \State ${\bf A} \leftarrow{\bf A}\backslash\{{\bf a}^t_j\in\columns({\bf A})\,|\, j\in\ind(k)\backslash i\}$\Comment{Remove categories $\not=v$}
    \State Update {\bf ind}
%    \For {${\bf a}\in\rows({\bf A})$}
%    \For {$i\in {\bf ind}(k)$}
%    \State $a_i\leftarrow\true$
%    \EndFor
%    \EndFor
    \Ensure $\langle{\bf A},{\bf ind}\rangle$ with $v$ substituted for variable $k$.
\end{algorithmic}
\end{algorithm}
% 
In the {\sf editrules} package, value substitution is performed by the {\sf substValue} function,
which accepts variable and category names.
<<echo=true>>=
substValue(E,"gender","female")
@

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Variable elimination by category resolution}
Given two edits $e$ and $e'$, with boolean representations ${\bf a}$ and
${\bf a}'$ respectively.  We define the {\em resolution operator} $\res_k$ as:
\begin{eqnarray}
\lefteqn{
    {\bf a} \res_k {\bf a}' = {\bf a}_1\land{\bf a}'_1\oplus\ldots\oplus
    {\bf a}_{k-1}\land{\bf a}'_{k-1}}\nonumber\\
&\oplus&    {\bf a}_k\lor{\bf a}'_k\oplus
    {\bf a}_{k+1}\land{\bf a}'_{k+1}\oplus\ldots\oplus
    {\bf a}_n\land{\bf a}'_n
\end{eqnarray}
%
Observe that this operator has the following properties, relevant for record checking.
\begin{eqnarray}
   \rho({\bf v})\in {\bf a}\res_j{\bf b} &\Rightarrow& \rho({\bf v})\in{\bf a} \lor \rho({\bf v})\in{\bf b}\\
   \rho({\bf v})\in {\bf a} &\Rightarrow& \rho({\bf v})\in{\bf a}\res_j{\bf b} \lor {\bf a}\res_j{\bf b}=\varnothing\\
   a_j = b_j &\Rightarrow& {\bf a}\res_j{\bf b} = {\bf a}\land {\bf b}. 
    \label{eqRedundant}
\end{eqnarray}
The operator is called resolution operator since its action strongly resembles
a resolution operation from formal logic.  If ${\bf a}_k= \lnot {\bf a}'_k$,
the operator ``resolves'' or eliminates the $k$th variable in $D$. 




That is, the
resulting edit (if any) is guaranteed to have $({\bf a}\res_j{\bf
a})_j=\textrm{\sc true}$.  The resolution operator is only defined on the
boolean representation of edits, and has no direct equivalent in the
set-theoretical representation of edits (Eq.\ \eqref{eqDefEdit}).  The only
exception is the special case of Eq.\ \eqref{eqRedundant}.  When
$a_j=b_j=\textrm{\sc true}$, the resulting edit is the intersection of the
original edits, in which case the resulting edit is redundant. 

By substitution in the definition, it can be shown that the resolution operator is
symmetrical, associative and idempotent. As a reminder, these properties are defined
as follows.
\begin{equation}
\begin{array}{ll}
\textrm{symmetry:}  &{\bf a}\res_j{\bf b} = {\bf b} \res_j {\bf a} \\
\textrm{associativity:}& ({\bf a}\res_j{\bf b})\res_j {\bf c} = {\bf a}\res_j({\bf b}\res_j {\bf c}).\\
\textrm{idempotency:} &{\bf a}\res_j {\bf a} = {\bf a}.
\end{array}
\end{equation}
The following distributive property also holds
\begin{equation}
\begin{array}{ll}
\textrm{distributivity:}& ({\bf a}\res_i{\bf b})\res_j{\bf c} = ({\bf a}\res_j{\bf c})\res_i({\bf b}\res_j{\bf c}).
\end{array}
\end{equation}

The resolution operator can be used to eliminate a category $j$ from a set of
edits as follows. First, collect all pairs of edits $({\bf a}^+,{\bf a}^-)$
which have $a^+_j=\lnot b^+_j$. Next, a new set of edits is created, consisting
of the ${\bf a}^+$ and every combination ${\bf a}^+\res_j{\bf a}^-$. A variable
$v_k$ can be eliminated by applying this procedure repeatedly to all categories
of a variable. The resulting boolean representation of the edits have
$a_j=\textrm{\sc true}$ for all $j\in D_k$. In set-theoretical terms this means
that for every resulting edit ${\bf e}_k=D_k$. Or in words: it does not depend
on the value of $v_k$ if a record ${\bf v}$ fails one of the resulting edits.



%
%
\begin{algorithm}[t]
\caption{{\sc eliminate($E$,$j$)}}
\label{eliminate}
\begin{algorithmic}
    \Require an {\sf editarray} $E=\langle{\bf A},{\bf ind}\rangle$, a variable index $k$
    \For{$j\in D_k$}
    \State $A^+ = \{{\bf a}\in{\rm rows}({\bf A})\,:\,a_j=\textrm{\sc true}\}$
    \State $A^- = \{{\bf a}\in{\rm rows}({\bf A})\,:\,a_j=\textrm{\sc false}\}$ 
    \State ${\bf A}\leftarrow A^+$
    \State $i\leftarrow |A^+|$
    \For{$({\bf a},{\bf b})\in A^+\times A^-$}
    \State $i \leftarrow i+1$
    \State ${\bf A}_{i}\leftarrow {\bf a}\res_j{\bf b}$
    \EndFor
    \EndFor
    \Ensure {\sf editarray} $\langle{\bf A}\rangle$ with variable $j$ eliminated
\end{algorithmic}
\end{algorithm}


\section{Equivalence to Fellegi and Holt's method}
\begin{equation}
F_k({\bf A}) = {\bf a}\res_k{\bf b}\res_k,\ldots,\quad {\bf a}, {\bf b},\ldots \in \rows({\bf A})
\end{equation}

\section{Error localization in categorical data}
\label{secErrLocCat}



\bibliographystyle{chicago}
\bibliography{editrules}

\end{document}
