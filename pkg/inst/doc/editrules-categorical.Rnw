%\VignetteIndexEntry{Categorical edit manipulation and error localization with the editrules package}
\documentclass[11pt, fleqn, a4paper]{article}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{array}
\usepackage[rounded]{syntax}
\usepackage{color, colortbl}
\usepackage{tex/smalltree}
\usepackage{natbib}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}
\usepackage{makeidx}
\makeindex

% shorthand to make '<category>' in syntax diagram
\newcommand{\syncat}{ $\textrm{\sf '}\langle category\rangle\textrm{\sf '}$ }


\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\Lor}{\lor}
\DeclareMathOperator*{\Land}{\land}
\DeclareMathOperator{\ocup}{\cup}
\DeclareMathOperator{\ocap}{\cap}
\DeclareMathOperator{\res}{\mathfrak{R}}
\newcommand{\rhomap}{\xrightarrow{\rho}}
\newcommand{\rows}{\textrm{rows}}
\newcommand{\columns}{\textrm{columns}}
\newcommand{\ind}{\textrm{\bf ind}}
\newcommand{\true}{\textrm{\sc true} }
\newcommand{\false}{\textrm{\sc false} }

\newtheorem{theorem}{Theorem}[subsection]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}
\newtheorem{definition}[theorem]{Definition}
\newcommand{\theend}{\hfill$\Box$}


\usepackage{float}
 
\floatstyle{boxed}
\newfloat{Rcode}{t}{rco}
\floatname{Rcode}{Figure}



% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}
\hyphenation{
    time-stamp 
    se-pa-ra-te-ly
    ge-ne-ra-li-zed
    e-dit-rules
}

<<echo=false>>=
library(editrules)
@

\title{Manipulation of categorical data edits and error localization with the
    {\sf editrules} package\\
{\small package version \Sexpr{packageVersion("editrules")}}}
\author{Mark van der Loo and Edwin de Jonge}
\begin{document}
\maketitle
\begin{abstract}
Analyses of categorical data are often hindered by the occurrence of
inconsistent or incomplete raw data. Although {\sf R} has many features for
analyzing categorical data, the functionality for error localization and
correction are currently limited.  The {\sf editrules} package is designed to
offer a user-friendly interface for edit definition, manipulation, and error
localization based on the generalized paradigm of Fellegi and Holt.  The
package is a toolbox, providing basic functionality such as rule definition,
error checking, rule consistency tests and more. On top of that, the package
includes algorithms which localize errors based on the generalized paradigm of
Fellegi and Holt. 

Under the hood, the package has several innovations of which the most important
one is a variable elimination method which -as far as the authors know- is new
to the field of data editing. The paper also introduces an elegant description
of edit rule manipulation in terms of the so-called resolution operator.

This is the second paper describing functionalities of the {\sf R} {\sf
editrules} package and marks the completion of {\sf editrules} version $2.0$.
The first paper \citep{jonge:2011} describes methods and implementation for
handling numerical data while this paper is concerned with handling categorical
data. 
\end{abstract}

\newpage
\tableofcontents
\listofalgorithms

\paragraph{Reading guide.} This paper describes the algorithms and some of the math
behind the package as well as the functionality of the {\sf editrules} package.
Readers less interested in the technical background who want to get started quickly
can skip some technical sections and read sections
\ref{sIntroduction}   $\rightarrow$ 
\ref{sseditarray} $\rightarrow$
\ref{sscommonfunctions} $\rightarrow$
\ref{ssvaluesubstitution} $\rightarrow$ 
\ref{sseliminateexample} $\rightarrow$
\ref{sslocalizeerrors} $\rightarrow$
\ref{sserrorlocalizer}.

\newpage


\section{Introduction}
\label{sIntroduction}

Analyses of categorical data are often hindered by occurrences of incomplete or
inconsistent raw data records.  The process of locating and correcting such
errors is referred to as {\em data editing}, and it has been estimated that
National Statistics Institutes spend up to 40\% of their resources on this
process \citep{waal:2011}. For this reason, considerable attention is paid to
the development of data editing methods that can be automated. Since data are
often required to obey many interrelated consistency rules, data
editing can be too complex to perform manually. \citet{winkler:1999} mentions
practical cases where records have to obey 250, 300 or even 750 internal
consistency rules.  Although the {\sf R} statistical environment has numerous
facilities for analyzing categorical data [See {\em e.g.} \citet{husson:2010}],
the options for error localization and record correction are currently limited.

This paper presents the {\sf editrules} package which was developed to help
closing the gap between raw data retrieval and data analysis with {\sf R}.  The
main purpose of the {\sf editrules} package is to provide a user-friendly
environment for handling data restriction rules, to apply those rules to data,
and to localize erroneous fields in data based on the generalized principle of
\cite{fellegi:1976}.  The package does not offer functionality for data
correction. However, it does facilitate the identification of the set of
solutions for an error correction problem.

Under the hood, the package contains several innovations with respect to the
branch-and-bound algorithm for error localization in categorical data described
in \cite{waal:2011}. The most important innovation is a variable elimination
algorithm which allows for on-the-fly redundant rule removal. As far as the
authors know, this algorithm is new to the field of data editing. To facilitate
the description of algorithms and their properties, we  also introduce a
formulation of categorical edit manipulations in terms of the so-called
resolution operator.  This formulation allows for elegant algebraic proofs of
properties of the algorithms and rule manipulations applied in the {\sf
editrules} package. 

The current paper complements our previous paper on the treatment of numerical
data \citep{jonge:2011}. We describe the algorithms underlying {\sf editrules}'
functionality and the internal representation of categorical data.  Examples in
{\sf R} code are given throughout the text to assist new users in getting
started with the package.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Categorical data and edit rules}
The value domain of categorical data records is usually limited by rules
interrelating these variables.  The simplest examples are cases where the value
of one variable excludes values of another variable. For example: if the age
class of a person is ``child'', then (by law) the marital status cannot be
``married''. In survey or administrative data, violations of such rules are
frequently encountered. Resolving such violations is an important step prior to
data analysis and estimation.

In this section we describe the representation of edits and records as
implemented in the {\sf editrules} package. Subsection \ref{ssboolrep}
describes the background while subsection \ref{sseditarray} describes
implementation and gives coded examples.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The {\sf editarray} object}
\label{sseditarray}
\index{editarray@{\sf editarray}}
In the {\sf editrules} package, a set of categorical edits is represented as an {\sf editarray}
object. Formally, we denote an {\sf editarray} $E$ for $n$ categorical variables and $m$ edits as
(brackets indicate a combination of objects)  
\begin{equation}
    E = \langle {\bf A},{\bf ind}\rangle\textrm{, with }{\bf A}\in\{0,1\}^{m\times d}\textrm{ and }
    d = \sum_{k=1}^n d_k,
    \label{eqEditarray}
\end{equation}
Each row ${\bf a}$ of ${\bf A}$ contains the boolean representation of one edit, and the
$d_k$ denote the number of categories of each variable.  The object {\bf ind}
is a nested {\sf list} which relates columns of {\bf A} to variable names and
categories.  Labeling variables with $k\in1,2,\ldots,n$ and category values
with $v_k\in 1,2,\ldots,d_k$, we use the following notations:
\begin{eqnarray}
\label{eqInd1}
    {\bf ind}(k,v_k) &=& \sum_{l< k }d_l + v_k\\
    {\bf ind}(k)   &=& \{{\bf ind}(k,v_k)\,|\, v_k\in D_k\}.
\label{eqInd2}
\end{eqnarray}
So $\ind(k,v_k)$ is the column index in {\bf A} for variable $k$ and category $v_k$
and $\ind(k)$ is the set of column indices corresponding to all categories of
variable $k$.  The {\sf editarray} is the central object for computing with
categorical edits, just like the {\sf editmatrix} is the central object for
computations with linear edits.

It is both tedious and error prone to define and maintain an {\sf editarray} by hand.
In practice, categorical edits are usually stated verbosely, such as: ``a male
subject cannot be pregnant'', or ``an under-aged subject cannot be married''.
To facilitate the definition of edit arrays, {\sf editrules} is equipped with a
parser, which takes {\sf R}-statements in {\sf character} format, and translates them
to an {\sf editarray}.

%
\begin{Rcode}
<<keep.source=true>>=
E <- editarray(c(
    "gender %in% c('male','female')",
    "pregnant %in% c('yes','no')",
    "if (gender == 'male') pregnant == 'no'"
    )
)
E
datamodel(E)
@
\caption{Defining a simple {\sf editarray} with the {\sf editarray} function.
The array is printed with abbreviated column heads, which themselves consist of
variable names and categories separated by a colon (by default). When printed
to screen, a {\sf character} version of the edits is shown as well, for
readability.
}
\label{Reditarray}
\end{Rcode}
%
Figure \ref{Reditarray} shows a simple example of defining an {\sf editarray} with
the editrules package.  The first two edits in Figure \ref{Reditarray} define
the data model. The {\sf editarray} function derives the datamodel based on the
variable names and categories it finds in the edits, whether they are
univariate (defining domains) or multivariate. This means that if all possible
variables and categories are mentioned in the multivariate edits, the correct
datamodel will be derived as well. 

When printed to the screen, the boolean array is shown with column heads of the form
\begin{quote}
{\sf <abbreviated var. name><separator><abbreviated cat. label>}
\end{quote}
where both variable names and categories are abbreviated for readability, and
the standard separator is a colon ({\sf :}). The separator may not occur as a
symbol in either variable or category name, and its value can be determined by
passing a custom {\sf sep} argument to {\sf editarray}.
For convenience, the function {\sf datamodel} accepts an {\sf editarray} as
input and returns an overview of variables and their categories for easy
inspection in the form of a {\sf data.frame}.

Internally, {\sf editarray} uses the {\sf R} internal {\sf parse} function to
transform the {\sf character} expressions to a parse tree, which is
subsequently traversed recursively to derive the entries of the editmatrix. The
opposite is also possible. The {\sf R} internal function {\sf as.character} has
been overloaded to derive a {\sf character} representation from a boolean
representation. When printed to the screen, both the boolean and textual
representation are shown.

Univariate edits define the domain of a variable. The domains form together a
data model. A domain can be defined with common {\sf R} syntax using the ${\sf
\%in\%}$ operator. If a domain is defined explicitly, it must follow the
following syntax diagram.
\begin{syntdiag}
    "\""
    <variable> "\%in\%"
    \begin{stack}
        "c("\begin{rep}\syncat\\","\end{rep}")"\\
        <identifier>\\
        "c(TRUE, FALSE)"
    \end{stack}
    "\""
\end{syntdiag}
Here, $\langle variable\rangle$ is the name of a categorical variable, and $\langle
category\rangle$ is a literal category name. Note that the category name is
enclosed by single quotes while the entire statement is between double quotes.
That is, the entire statement has to be offered in string format to {\sf
editarray}. The $\langle identifier\rangle$ is the name of a predefined {\sf
character} variable storing the unique categories for a variable. In principle,
$\langle identifier\rangle$ may be replaced by any valid {\sf R} symbol
evaluating to a {\sf character} or {\sf factor} vector. However, such constructions are not
recommended, since multivariate edit rules depend on a fixed datamodel.

The multivariate rules can be defined in two ways. The most useful and common
way to define edits follows the following syntax diagram.

\begin{syntdiag}
    "\"if ("\begin{rep}
          <set expression>\\
          \begin{stack}"\&\&"\\ "\&"\end{stack}
       \end{rep}
        ")"
        \begin{stack}
            \begin{rep}
                <set expression>\\
                \begin{stack}"||"\\ "|"\end{stack}
            \end{rep} \\
        {\sc false}
        \end{stack}
    "\""
\end{syntdiag}

Where each $\langle$\textit{set expression}$\rangle$ is a logical statement, following

\begin{syntdiag}
    \begin{stack}
        \\"!"
    \end{stack}
        <variable>
        \begin{stack}
            \\
            \begin{stack} "=="\\ "!="\end{stack} 
                \begin{stack} \syncat \\ \begin{stack}\true\\ \false\end{stack}\end{stack}\\
                    "\%in\%"
                    \begin{stack} 
                        "c(" \begin{rep}\syncat\\ "," \end{rep} ")"\\
                        <identifier>\\
                        \begin{stack} \true\\ \false\end{stack}
                    \end{stack}
        \end{stack}
\end{syntdiag}

The reader can check that the examples given in Figure \ref{Reditarray} follow this syntax.
The example below illustrates the use of separately defined data models and boolean
categories.
<<keep.source=true>>=
xval <- letters[1:4]
yval <- c(TRUE,FALSE)
( M <- editarray(c( 
    "x %in% xval",
    "y %in% yval",
    "if ( x %in% c('a','b') ) !y "
    )) )
@
%
The second way to define multivariate edits is based on rewriting on the basic classical
logic law $P\Rightarrow Q = \lnot P\lor Q$. It involves the following syntax diagram.
\begin{syntdiag}
        "\""
        \begin{rep}
          <set expression>\\
          \begin{stack}"||"\\ "|"\end{stack}
        \end{rep} "\""
\end{syntdiag}
Where each $\langle set expression\rangle$ is as in the syntax diagram above.  In
practice, a user will commonly not use this form since it is less readable.
However, the {\sf as.character} method for {\sf editarray} can generate such
statements by passing the argument {\sf useIf=FALSE}, as shown below.
<<>>=
as.character(M,useIf=FALSE)
@
The main advantage of this form is that
contrary to the  {\sf if()} form, it allows for vectorized checking of edits,
which is why it is used internally.
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Coercion, checking, redundancy and feasibility}
\label{sscommonfunctions}
The {\sf editrules} package is equipped with functions operating on sets of
edits represented as an {\sf editarray}. An overview is given in Table
\ref{tabBasicfunctions}.  The {\sf datamodel} function extracts the variables
and categories from an {\sf editarray}, and returns them as a two-column {\sf
data.frame}. With {\sf as.data.frame} or {\sf as.character} one can coerce an
editarray so that it can be written to a file or database. Character coercion
is used when edits are printed to the screen. Optionally, coercing the
datamodel to character form can be switched off. The result of {\sf
as.data.frame} has columns with edit names, a character representation of the
edits and a column for remarks.

The function {\sf violatedEdits} takes an {\sf editarray} and a {\sf
data.frame} as input and returns a logical matrix indicating which record
(rows) violate which edits (columns). It works by parsing the {\sf editarray}
to R-expressions and evaluating them within the {\sf data.frame} environment.
By default, the records are checked against the data model. This can be turned
off by providing the optional argument {\sf datamodel=FALSE}. 

\index{editarray@{\sf editarray}!functions}
\begin{table}
\begin{threeparttable}
\caption{Functions for objects of class {\sf editarray}. Only mandatory
arguments are shown, refer to the built-in documentation for optional
arguments.}
\label{tabBasicfunctions}
\begin{tabular}{ll}
\hline
Function        & description \\
\hline
{\sf datamodel(E)}            & get datamodel \\
{\sf getVars(E)}              & get a list of variables\\
{\sf as.data.frame(E)}        & coerce edits to {\sf data.frame}\\
{\sf contains(E)}             & which edits contains which variable\\
{\sf as.character(E)}         & coerce edits to {\sf character} vector\\
{\sf blocks(E)}               & Get list of independent blocks of edits\\
{\sf reduce(E)}               & Remove empty unnecessary variables and rows\\
{\sf isObviouslyRedundant(E)} & find redundancies [Eq.\ \eqref{eqRedundancy1}], duplicates\\
{\sf duplicated(E)}           & find duplicate edits\\
{\sf isSubset(E)}             & find edits, subset of another edit [Eq.\ \eqref{eqRedundancy2}]\\
{\sf isObviouslyInfeasible(E)}& detect simple contradictions\\ 
{\sf isFeasible(E)}           & detect if at least 1 valid record exists\\
{\sf substValue(E,var,value)} & substitute a value\\
{\sf eliminate(E,var)}        & eliminate a variable (sect.\ \ref{sseliminateexample})\\
{\sf violatedEdits(E,dat)}    & check which edits are violated by {\sf x}\\
{\sf localizeErrors(E,dat)}   & localize errors (sect.\ \ref{sslocalizeerrors})\\
{\sf errorLocalizer(E,x)}     & {\sf backtracker} for error localization (sect.\ \ref{sserrorlocalizer})\\
{\sf summary(E)}              & summarize the content of {\sf E}\\
{\sf plot(E)}                 & plot a graph of {\sf E} (requires {\sf igraph} package)\\
\hline
\end{tabular}
\end{threeparttable}
\end{table}

When manipulating edit sets, redundant edits of the form of Eq.\
\eqref{eqRedundancy1} may arise. Such redundancies can be detected in the
boolean representation with {\sf isObviouslyRedundant}. By default, this
function also checks for duplicate edits, but this may be turned off. The
function {\sf duplicated} is overloaded from the standard {\sf R} function and
the function {\sf isSubset} (pseudocode in Algorithm \ref{algIsSubset}) detects
which edits are a subset or duplicate of another one. In the actual {\sf R}
implementation, the only explicit loop is a call to {\sf R}'s {\sf vapply}
function.  The other loops are avoided using {\sf R}'s indexing  and
vectorization properties.
\index{editarray@{\sf editarray}!redundancy}
%
\begin{algorithm}[t]
\caption{{\sc isSubset}$(E)$}
\label{algIsSubset}
\begin{algorithmic}[1]
\Require An editarray $E=\langle{\bf A},\ind\rangle$.
\State ${\bf s} \leftarrow (\false)^m$
\For {$({\bf a}^{(i)},{\bf a}^{(i')})\in \rows({\bf A})\times\rows({\bf A})$ }
  \If {${\bf a}^{(i)}\lor {\bf a}^{(i')}={\bf a}^{(i')} $}
    \State $s_i\leftarrow\true$
  \EndIf
\EndFor
\Ensure Boolean vector $\bf s$ indicating which edits represented by  {\bf A} are a subset of another edit. 
\end{algorithmic}
\end{algorithm}


Manipulations may also lead to edits of the form $e=D$, in which case every possible
record is invalid, and the editarray has become impossible to satisfy. The function
{\sf isObviouslyInfeasible} detects whether any such edits are present. The function
{\sf isFeasible} checks if the set of edits in it's argument allows at least one
\index{editarray@{\sf editarray}!feasibility}
valid record. This may yield results which are counterintuitive at first glance.
For example, consider set of edits on the domain $D=\{(x,y)\in\{{\sf a},{\sf b}\}\times\{{\sf c},{\sf d}\}\}$.
<<keep.source=true>>=
M <- editarray(c(
    "x %in% c('a','b')",
    "y %in% c('c','d')",
    "if ( x == 'a' ) y == 'c'",
    "if ( x == 'a' ) y != 'c'"))

@
This set of edits is feasible, even though edits $e_1$ and $e_2$ seem to contradict each other: 
<<>>=
isFeasible(M)
@
The explanation is that $e_1$ and $e_2$ contradict each other only when 
$x={\sf a}$, so
<<keep.source=true>>=
isFeasible(substValue(M,'x','a'))
@
where the function {\sf substValue} is discussed in the next section. One can check
that the record $(x={\sf b},y={\sf d})$ indeed satisfies all edits in ${\sf M}$.

The feasibility check works by eliminating all variables in an {\sf editarray} one by
one until either no edits are left or an obvious contradiction is found. Eliminating
all variables amounts constructing the solution of an error localization problem
in the branch-and-bound algorithm of \cite{waal:2003} where all variables have to be 
adapted. Variable elimination is discussed further in the next section while error localization is discussed
in Section \ref{secErrLocCat}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SECTION 3
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Manipulation of categorical restrictions}
The basic operations on sets of categorical edits are value substitution and
variable elimination. The former amounts to adapting the datamodel underlying
the edit set while the latter amounts to deriving relations between variables
not involving the eliminated variable. 

In the next subsection we give an example of value substitution with the {\sf
editrules} package, as well as some background. In subsection
\ref{sscategoryresolution} we describe a variable elimination method, which to
the authors seems new to the field of data editing. In subsection
\ref{ssequivalence} it is shown that the method yields results equivalent to
Fellegi and Holt's elimination method.  Finally, in subsection
\ref{sseliminateexample} we give an example of eliminating variables with the
{\sf editrules} package. 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Value substitution}
\label{ssvaluesubstitution}
If it is assumed that in a record, one of the variables takes a certain value,
that value may be substituted in the edit rules. In the boolean representation
this amounts to removing all edits which exclude that value, since the record
cannot violate those edits. Secondly, the columns related to the substituted
variable but not to the substituted category are removed, thereby adapting the
datamodel to the new assumption. Algorithm \ref{substValue} gives the
pseudocode for reference purposes.
\index{editarray@{\sf editarray}!value substitution}
%
\begin{algorithm}[t]
\caption{{\sc substValue($E$,$k$,$v$)}}
\label{substValue}
\begin{algorithmic}[1]
    \Require an {\sf editarray} $E=\langle{\bf A},{\bf ind}\rangle$, a variable index $k$ and a value $v$
    \State $i \leftarrow \ind(k,v)$
    \State ${\bf A}\leftarrow {\bf A}\backslash\{{\bf a}\in\rows({\bf A})\,|\,a_i=\false\}$\Comment{Remove rows not involving $v$ }
    \State ${\bf A} \leftarrow{\bf A}\backslash\{{\bf a}^t_j\in\columns({\bf A})\,|\, j\in\ind(k)\backslash i\}$\Comment{Remove categories $\not=v$}
    \State Update {\bf ind}
    \Ensure $\langle{\bf A},{\bf ind}\rangle$ with $v$ substituted for variable $k$.
\end{algorithmic}
\end{algorithm}
% 

In the {\sf editrules} package, value substitution is performed by the {\sf
substValue} function, which accepts an {\sf editarray}, a variable name and a
category name. In the following example the editmatrix defined in Figure
\ref{Reditarray} is used.
<<echo=true>>=
substValue(E,"gender","female")
@
In this case, the variable {\em gender} is substituted by the value {\sf female}. The rules
concerning $gender={\sf male}$ may be deleted, so here only the datamodel is left without
any multivariate rules. In fact, the datamodel itself may be reduced, which
can be achieved by setting the option {\sf reduce=TRUE}.
<<>>=
substValue(E,"gender","female",reduce=TRUE)
@





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{An example with {\sf eliminate}}
\label{sseliminateexample}
\index{editarray@{\sf editarray}!variable elimination}
The purpose of the {\sf eliminate} function is to derive all possible non-redundant
edits from an edit set that do not contain a certain variable. For categorical data
edits, this amounts to logical resolution. For example, consider the syllogism
which was also discussed in Example \ref{exResolution}:

\begin{tabular}{lm{0.8\textwidth}}
\\
$P_1$ & Under-aged people cannot be married\\
$P_2$ & A marriage partner has to be married\\
\hline
$C$ & An under-aged subject cannot be a marriage partner.\\   
\\
\end{tabular}\\
Here, the conclusion $C$ is derived from premises $P_1$ and $P_2$ by eliminating
{\em marital status}. In {\sf editrules} the above operation can be performed as
follows. We first define a data model and edit rules:

<<keep.source=true>>=
E <- editarray(c(
    "age %in% c('under-aged','adult')",
    "maritalStatus %in% c('married','not married')",
    "positionInHousehold %in% c('partner','child','other')",
    "if (age == 'under-aged') maritalStatus != 'married'",
    "if (positionInHousehold == 'partner') maritalStatus == 'married'"
))
@
We may derive the conclusion by eliminating the {\em marital status} variable:
<<>>=
eliminate(E,'maritalStatus')
@
This indeed yields the right conclusion. Alternatively, we may eliminate {\em age}:
<<>>=
eliminate(E,'age')
@
This deletes the only rule actually involving {\em age}. That is, no new rules not involving
{\em age} can be derived.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Error localization in categorical data}
\label{secErrLocCat}

\subsection{A Branch and bound algorithm}
\label{sBandB}
The editrules package implements an error localization algorithm, based on the
branch-and-bound algorithm of \cite{waal:2003a}. The algorithm has been
extensively described in \cite{waal:2003} and \cite{waal:2011}. The algorithm
is similar to the branch-and-bound algorithm used for error localization in
numerical data in the editrules package as described in \citet{jonge:2011},
except that the elimination and substitution subroutines are implemented for
categorical data.

In short, a binary tree is created with the full set of edits and an erroneous
record at the root node. Two child nodes are created. In the first child node
the first variable of the record is assumed correct, and it's values is
substituted in the edits. In the second child node the variable is assumed
incorrect and it is eliminated from the set of edits. The tree is continued
recursively until choices are made for each variable. Branches are pruned when
they cannot lead to a solution, leaving a partial binary tree where each path
from root to leaf represents a solution to the error localization problem.
Computational complexity is reduced further by pruning branches leading to
higher-weight solutions then solutions found earlier.

Recall the datamodel of Example \ref{datamodel}, with variables {\em marital status},
{\em age} and {\em position in household}. We define the following two edits:

\begin{tabular}{ll}
\\
$e^{(1)}$ & An under-aged subject cannot be married\\
$e^{(2)}$ & A (marriage) partner has to be married\\
\\
\end{tabular}\\
%
As an example we treat the following record with the branch-and-bound algorithm to 
localize the errors:
\begin{equation}
v = ({\sf married},\textrm{\sf under-aged},{\sf partner }).
\end{equation}
At the beginning of the algorithm, only the root node is filled. The situation may be 
represented as follows:\\
%%%%%%%%%%%%%
% T0: ROOT NODE
%%%%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &1&0&0&0&1&0&1&0&0\\
        \hline
        {\bf a}^{(1)}&1&0&0&0&1&0&1&1&1\\
        {\bf a}^{(2)}&0&1&1&1&1&1&1&0&0
    \end{array}
$
\end{tabular}\hfill  Root node, $w=0$,
\end{center}
%
where ${\bf v}=\rho(v)$, and ${\bf a}^{(1)}$ and ${\bf a}^{(2)}$ are the boolean
representations of $e^{(1)}$ and $e^{(2)}$ respectively. The record and edits are
denoted in boolean representation as shown in Example \ref{datamodel}.  The
weight $w$ counts the number of variables that are assumed to be incorrect,
which at the root node is zero. 


The tree is traversed in depth-first fashion. In the first step, we substitute
{\sf married} in {\em marital status}, yielding
%%%%%%%%%%%
% T0L
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &1& & & &1&0&1&0&0\\
        \hline
       {\bf a}^{(1)}&1 & & & &1&0&1&1&1\\
    \end{array}
$
\end{tabular}\hfill Subst. mar. stat., $w=0$.
\end{center}
Here, ${\bf a}^{(2)}$ is removed, since it has no meaning for {\bf v} anymore. The
positions for the categories unmarried, widowed and divorced are left empty
here to signify that the datamodel has a fixed marital status now. The dark
part of the tree on the left shows which nodes have been treated. Continuing
we find

%%%%%%%%%%%
% T0LL
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &1& & & &1& &1&0&0\\
        \hline
        {\bf a}^{(1)}&1 & & & &1 & &1&1&1\\
    \end{array}
$
\end{tabular}\hfill Subst. age., $w=0$.
\end{center}
At this point we have fixed the value for {\em marital status} and {\em age}.
It can be seen from the value of ${\bf a}^{(1)}$ for {\em position in
household} that no matter what value is chosen for that field, the value ${\bf
v}\cdot{\bf a}^{(1)}=3$. This shows that this path will never lead to a valid
solution.  We therefore prune the tree here, go up one node and turn right. 
%%%%%%%%%%%
% T0LR
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v} &1& & & &\phantom{1}&\phantom{0}&1&0&0\\
\hline
\phantom{e_1}&&&&&&&&
    \end{array}
$
\end{tabular}\hfill Elim. age, $w=1$.
\end{center}
Eliminating the {\em age} variable yields an empty edit set. We may continue down
and substitute the value {\sf partner} for {\em position in household}.
\begin{center}
%%%%%%%%%%%
% T0LRL
%%%%%%%%%%
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v} &1& & & &\phantom{1}&\phantom{0}&1& & \\
\hline
\phantom{e_1}&&&&&&&&
    \end{array}
$
\end{tabular}\hfill Subst. hh. pos., $w=1$.
\end{center}
This yields the first solution: only the {\rm age} variable needs to be
changed.  In search for more solutions, we move up the tree and try to
eliminate {\em position in household}. However, since eliminating {\em position
in household} would increase the weight to 2 we will prune the tree at this
point. Moving up to the root node and eliminating {\em marital status} gives
%%%%%%%%%%%
% T0R
%%%%%%%%%%
\begin{center}
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Er\Tr
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &\phantom{1}&\phantom{0}&\phantom{0}&\phantom{0}&1&0&1&0&0\\
        \hline
        {\bf a}^{(3)} &1&1&1&1&1&0&1&0&0\\
    \end{array}
$
\end{tabular}\hfill Elim. mar. stat., $w=1$.
\end{center}
Here ${\bf a}^{(3)}={\bf a}^{(1)}\res_1{\bf a}^{(2)}$. It is interpreted as the
rule that under-aged people cannot be a partner in the household (no matter
what the value of {\em marital status} is).  Creating the next child node by
substituting {\em age}, we get
\begin{center}
%%%%%%%%%%%
% T0RL
%%%%%%%%%%
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Er\Tr\Erl\Trl
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v}  &\phantom{1}&\phantom{0}&\phantom{0}&\phantom{0}&1&\phantom{0}&1&0&0\\
        \hline
        {\bf a}^{(3)} &1&1&1&1& 1 &\phantom{0}&1&0&0\\
    \end{array}
$
\end{tabular}\hfill Subst. age, $w=1$.
\end{center}
Going down the tree and substituting {\em position in household} yields
\begin{center}
%%%%%%%%%%%
% T0RLL
%%%%%%%%%%
\begin{tabular}{m{20mm}m{5.5cm}}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Elr\Tlr\Elrl\Tlrl%\Elrr\Tlrr\XTlrr
    \Er\Tr\Erl\Trl\Erll\Trll
\end{picture}
&$
    \begin{array}{l|cccc|cc|ccc}
        {\bf v} &\phantom{1}&\phantom{0}&\phantom{0}&\phantom{0}&1&&1&&\\
        \hline
        {\bf a}^{(3)} &1&1&1&1&1&\phantom{0}&1&\phantom{0}&\phantom{0}\\
    \end{array}
$ 
\end{tabular}\hfill Subst. hh. pos., $w=1$.
\end{center}
However, whatever value we would choose for {\em marital status}, it would
always result in an erroneous record since ${\bf a}^{(3)}$ has \true on all
categories of that variable. Therefore, we go up one step in the tree.
Eliminating {\em position in household} would increase the weight to 2, but
since we already found a solution with weight equal to 1, this path need not be
followed. We go up another node and bound on the fact that eliminating {\em
age} would yield the same problem. The final tree may be represented as
follows:
\begin{center}
\begin{picture}(1400,1000)
    \treeframe
    \Troot\El\Tl\Ell\Tll\XTll
    \Elr\Tlr\Elrl\Tlrl
    \Er\Tr\Erl\Trl\Erll\Trll\XTrll
\end{picture}$\:$.
\end{center}
Here, every evaluated node is colored black, and a node is crossed when a bound
condition was encountered. The only (minimal) solution created is represented
by the path substitute {\em marital status} $\rightarrow$ eliminate {\em age}
$\rightarrow$ substitute {\em position in household}. This corresponds to the
solution where {\em age} has to be altered to fix the record, and indeed
changing {\em age} from {\sf under-aged} to {\sf adult} will make the record
fully valid. Note that the branch-and-bound algorithm reduced the number of
nodes to be evaluated from $15$ to $8$ in this case.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Error localization with {\sf localizeErrors}}
\label{sslocalizeerrors}
\index{error localization!with {\sf localizeErrors}}
%
%
\begin{Rcode}
<<keep.source=true>>=
E <- editarray(c(
    "age %in% c('under-aged','adult')",
    "maritalStatus %in% c('unmarried','married','widowed','divorced')",
    "positionInHousehold %in% c('marriage partner', 'child', 'other')",
    "if( age == 'under-aged' ) maritalStatus == 'unmarried'",
    "if(positionInHousehold == 'marriage partner') maritalStatus == 'married'"
    )
)

(dat <- data.frame(
    maritalStatus=c('married','unmarried','widowed' ), 
    age = c('under-aged','adult','adult' ),
    positionInHousehold=c('marriage partner','other','marriage partner')
))

set.seed(1)
localizeErrors(E,dat)
@
\caption{Localizing errors in a {\sf data.frame} of records. The data model is
as defined in Example \ref{datamodel}.  The randseed is set before calling {\sf
localizeErrors} to make results reproducible. The third record has degeneracy 2,
which means that the chosen solution was drawn uniformly from two equivalent
solutions with weight 1.}
\label{RlocalizeErrors}
\end{Rcode}
The function {\sf localizeErrors} applies the branch-and-bound algorithm to
determine the minimal weight error location for every record in a {\sf
data.frame}. The columns may be in {\sf character} or {\sf factor} format.  The
function has an identical interface for numerical data under linear edits and
categorical  data under categorical edits. It is implemented as an {\sf S3}
generic function, accepting either an {\sf editmatrix} or an {\sf editarray} as
the first argument and a {\sf data.frame} as the second argument. Further
arguments are a vector of variable weights, a maximum search time (in seconds)
to spend on a single record, a maximum weight and the maximum number of
variables which may be changed. The latter two arguments introduce extra bound
conditions in the branch-and-bound algorithm.

Even when variables are weighted, the solution to the error localization
problem may not be unique. In those cases {\sf localizeErrors} will draw
uniformly from the set of lowest-weight solutions. The degeneracy (number of
equivalent solutions found) is reported in the output.

The result of a call to {\sf localizeErrors} is an object of class {\sf errorLocation}.
It contains a boolean matrix with error locations for each record as well as a status 
report containing degeneracies, solution weights run times and whether the maximum runtime
was exceeded. It also contains a timestamp (in the form of a {\sf Date} object) and the
name of the user running {\sf R}. Table \ref{tblErrorLocation} gives an overview of
the slots involved.
%
\input{tex/errorLocation.tex}

In Figure \ref{RlocalizeErrors} an example of the use of {\sf localizeErrors} is
given. The data model and rules are as in subsection \ref{sBandB}. The records
are given by
<<keep.source=false,echo=false>>=
(dat <- data.frame(
    maritalStatus=c('married','unmarried','widowed' ), 
    age = c('under-aged','adult','adult' ),
    positionInHousehold=c('marriage partner','other','marriage partner')
))
@
The edits state that under-aged persons cannot be married and that one cannot be a
marriage partner if one is unmarried. Clearly, the first and third record
disobey some of these rules while the second record is valid. The first
record can be repaired by adapting age and the second record can be made
consistent by changing either {\em position in household} or {\em marital
status}. In the latter case, both solutions have equal weight and {\sf
localizeErrors} has drawn one solution.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\subsection{Error localization with {\sf errorLocalizer}}
\label{sserrorlocalizer}
\index{error localization!with {\sf errorLocalizer}}
Just like for linear edits, the function {\sf errorLocalizer} gives more
control over the error localization process since it allows to parameterize
the search separately for each record. This can be useful, for example when 
reliability weights are calculated for each record.

The {\sf errorLocalizer} function is described extensively in
\cite{jonge:2011}, so here we will discuss the example shown in Figure
\ref{RcatErrorLocalizer}.

The data model and edits are the same as in Figure \ref{RlocalizeErrors}. The
difference here is that a record must be offered as a named {\sf character}
vector. A call to {\sf errorLocalizer} generates a {\sf backtracker} object
which contains all information necessary to start searching the binary tree.
After calling {\sf \$searchNext()} the weight and first found solution are
returned, while the backtracker object stores some meta-information about the
process, most significantly the duration of the search.  A second call yields
an equivalent solution and the third call returns {\sf NULL}, indicating that
all minimal weight solutions have been found.
%
\begin{Rcode}
<<keep.source=TRUE>>=
# Define a record 
r <- c(age = 'under-aged', maritalStatus='married', positionInHousehold='child')
el <- errorLocalizer(E,r)
el$searchNext()

el$duration
el$maxdurationExceeded
el$searchNext()
el$searchNext()
@
\caption{Finding errors with {\sf errorLocalizer}. The data model and edits in {\sf E} are as in
Figure \ref{RlocalizeErrors}.}
\label{RcatErrorLocalizer}
\end{Rcode}


\clearpage
\section{Conclusions}
This paper describes the theory and implementation of categorical edit
manipulation of the {\sf editrules} package. Categorical restrictions may be
defined textually in standard {\sf R} syntax. New edits may be derived with the
resolution method. A new formulation of the elimination method in terms of the
resolution operator was developed which facilitated the development of a fast
elimination algorithm which seems to be new in the field of data editing.

The package offers functionality to check records against rules and can 
determine the location of errors based on the generalized principle of 
Fellegi and Holt. 

\clearpage
\addcontentsline{toc}{section}{Index}
\printindex



\end{document}


