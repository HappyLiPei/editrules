%\VignetteIndexEntry{Categorical edit manipulation and error localization with the editrules package}
\documentclass[11pt, fleqn, a4paper]{article}
\usepackage[english]{babel}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{threeparttable}
\usepackage{natbib}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\usepackage{threeparttable}
\DeclareMathOperator*{\argmin}{\arg\!\min}
\DeclareMathOperator*{\Lor}{\lor}
\DeclareMathOperator*{\Land}{\land}
\DeclareMathOperator{\ocup}{\cup}
\DeclareMathOperator{\ocap}{\cap}
\DeclareMathOperator{\res}{\mathfrak{R}}
\newcommand{\rhomap}{\xrightarrow{\rho}}
\newcommand{\rows}{\textrm{rows}}
\newcommand{\columns}{\textrm{columns}}
\newcommand{\ind}{\textrm{\bf ind}}
\newcommand{\true}{\textrm{\sc true} }
\newcommand{\false}{\textrm{\sc false} }

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{definition}{Definition}[section]

\usepackage{float}
 
\floatstyle{boxed}
\newfloat{Rcode}{t}{rco}
\floatname{Rcode}{Figure}



% stimulate latex to put multiple floats on a page.
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
\setcounter{totalnumber}{3}
\setcounter{dbltopnumber}{2}
\renewcommand{\topfraction}{.9}
\renewcommand{\textfraction}{.1}
\renewcommand{\bottomfraction}{.75}
\renewcommand{\floatpagefraction}{.9}
\renewcommand{\dblfloatpagefraction}{.9}
\renewcommand{\dbltopfraction}{.9}
\hyphenation{time-stamp}

<<echo=false>>=
library(editrules)
@

\title{Manipulation of categorical data edits and error localization with the {\sf editrules} package\\
{\small package version \Sexpr{packageVersion("editrules")}}}
\author{Mark van der Loo and Edwin de Jonge}
\begin{document}
\maketitle
\begin{abstract}
{\em This vignette is far from finished. Version 2.0 fo the package will have
the full vignette. At the moment, functionality for treating categorical data has alpha status and is not public yet.
Refer to the accompanying paper \cite{jonge:2011} for manipulation of linear edits.
}
\end{abstract}

\newpage
\tableofcontents
\newpage


\section{Introduction}
The value domain of categorical data records is usually limited by domain rules
interrelating these variables.  The simplest examples are cases where the value
of one variable excludes values of another variable. For example: if the age
class of a person is ``child'', then (by law) the marital status cannot be
``married''. In survey or administrative data, violations of such rules are
frequently encountered. Resolving such violations is an important step prior to 
data analysis and estimation.

A categorical data record $\bf v$ with $n$ variables may be defined as an
element of the cartesian product space $D$:
\begin{equation}
D = D_1\times D_2\times\ldots\times D_n,
\end{equation}
where each $D_k$ is a finite set of $d_k$ possible categories for the $i$th
variable.  Each restriction $e$ is a subset of $D$ and we say that that {\em if
${\bf v}\in e$ then $\bf v$ violates $e$}. Conversely, when ${\bf v}\not\in e$
we say that ${\bf v}$ {\em satisfies} $e$. In data editing literature, such
rules are referred to as {\em edit rules} or {\em edits}, in short. In the
context of contingency tables they are referred to as {\em structural zeros}
since each rule implies one or more cells in the $d_1\times d_2\times\ldots
\times d_n$ contingency table must be zero. A record is {\em  valid} if it satisfies
every edit imposed on $D$.


Large, complex surveys may consist of hundreds of interrelated rules and
variables, which impedes resolution of edit violations and renders manual
manipulation infeasible. The {\sf R} package {\sf editrules}  offers functionality to
define, manipulate and maintain sets of edit rules with relative ease. It also
implements error localization functionality based on the generalized principle
of \citep{fellegi:1976}, which states that one should find the smallest
(weighted) number of variables whose values can be adapted such that all edits
can be satisfied. Fellegi and Holt's principle should be considered as the last
resort of data editing. It is useful in situations where a record violates one
or more edits and there is no information about the cause of the error. In
certain cases, the cause of error can be estimated with near certainty, for
example in the case of typing errors in numerical data.  We refer the reader to
\cite{scholtus:2008,scholtus:2009} and \cite{loo:2011} for such cases.

In the remainder of this paper the representation and manipulation of edits is
discussed and algorithms are given in pseudocode. Also, coded examples are
given, al of which can be executed after loading the editrules package.















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% SECTION 1
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Defining and checking categorical constraints}
In the next section we describe the representation of edits and records as
implemented in the {\sf editrules} package. Readers not interested in the
underlying principles may skip Section \ref{sectBoolrep}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Boolean representation of edits and records}
\label{sectBoolrep}
Categorical records may be represented as  a vector of boolean values. A
boolean vector of dimension $d$ is an element of the boolean algebra 
\begin{equation}
\mathbb{B}^{d}=\left(\{0,1\}^{d},\land,\lor,\lnot\right),
\end{equation}
where 0 and 1 have the usual interpretations {\sc false} and {\sc true} and the
logical operators work elementwise on their operands. To facilitate the
discussion we will also allow the standard arithmetic operations addition and
subtraction on boolean vectors (this is also consistent with the way {\sf R}
handles vectors of class {\sf logical}). 

To represent a record ${\bf v}=(v_1,v_2,\ldots,v_n)$, assign to every category
$i$ in $D_k$ a unique standard basisvector $\vec{\delta}_k(i)$ of
$\mathbb{B}^{d_k}$.  The boolean representation $\rho({\bf v})$ of the full
record is the direct sum
%
\begin{equation}
    {\bf v} \xrightarrow{\rho} \vec{\delta}_{1}(v_1)\oplus\vec{\delta}_{2}(v_2)\oplus\ldots\oplus\vec{\delta}_n(v_n).
\end{equation}
The diminsion $d$ of $\rho({\bf v})$ is given by the total number of categories of all variables
\begin{equation}
d = \sum_{k=1}^n d_k.
\end{equation}
When each record in a dataset is represented this way, summing the vectors
yields the $d$-dimensional vecorized representation of the $d_1\times
d_2\times\ldots\times d_n$ contingency table of the dataset. This is sometimes
called the complete disjunctive table. 

An edit $e$ is a subset of $D$ which can be written as the cartesian product
\begin{equation}
    e = A_1\times A_2\ldots\times A_n\textrm{, where } A_{k}\subseteq D_k,\: k=1,2,\ldots n. 
    \label{eqDefEdit}
\end{equation}
The interpretation of an edit is that if a record ${\bf v}\in e$, then ${\bf
v}$ is considered invalid. An edit, expressed as above is said to be in {\rm
normal form}.  A variable $v_k$ is {\em involved} in an edit if $A_k\subset
D_k$.  Conversely, we say that $e$ {\em involves} $v_k$ if $v_k$ is involved in
$e$. A variable $v_k$ for which $A_k=D_k$ is not involved in $e$.  Since every
category $i$ of $D_k$ is mapped to a unique basis vector $\vec{\delta}_k(i)$,
edits have a boolean representation $\rho(e)$, given by
\begin{eqnarray}
    e &\xrightarrow{\rho}&
    \Lor_{i\in A_1}\vec{\delta}_1(i)\oplus
    \Lor_{i\in A_2}\vec{\delta}_2(i)\oplus\ldots
    \oplus\Lor_{i\in A_n}\vec{\delta}_n(i),
\end{eqnarray}
which may simply be written as
\begin{equation}
    \rho(e) = {\bf a}_1\oplus{\bf a}_2\oplus\ldots\oplus{\bf a}_n={\bf a} .
\label{EqRhoE}
\end{equation}
A simple example is given in Figure \ref{Reditarray}. It is easy to check that
an edit contains variable $k$  if and only if the inner product ${\bf 1}_{d_k}\cdot{\bf a}_k<d_k$,
where ${\bf 1}_{d_k}$ is a $d_k$ vector of ones.

A record ${\bf v}$
violates an edit if $v_k\in A_k$, $k=1,2,\ldots n$.  In the boolean
representation this can be written as a condition on the standard inner product
between the boolean representation of a record and an edit:
\begin{equation}
\sum_{k=1}^n \vec{\delta}_k(v_k)\cdot{\bf a}_k =\rho({\bf v})\cdot{\bf a} =  n.
\label{eqViolatedEdits}
\end{equation}

Suppose that $E$ is a set of edits of the form \eqref{eqDefEdit}. It is not difficult to verify that an 
edit $e\in E$ is redundant if
%
\begin{eqnarray}
    \label{eqRedundancy1}
    A_k &=&\varnothing,\textrm{ for any } k\in1,2,\ldots,n\\
    \lefteqn{\textrm{or}}\nonumber\\
    \label{eqRedundancy2}
    e   &\subseteq& e'\textrm{ with  } e'\in E.
\end{eqnarray}
In \eqref{eqRedundancy1}, $e$ is redundant since it cannot contain any records.
It can be tested by checking if any ${\bf 1}_{d_k}\cdot{\bf a}_k=0$.  In the case
of \eqref{eqRedundancy2}, $e$ is redundant because any edit violating $e$ also
violates $e'$. Using $\rho(e)={\bf a}$ and $\rho(e')={\bf a}'$, this can be
tested by checking if ${\bf a}\land{\bf a}'={\bf a}$ or equivalently if ${\bf
a}\lor {\bf a}'={\bf a}'$.

In the {\sf editrules} the boolean representation is mainly used to store edits
and to manipulate them with methods like variable substitution and elimination.
Data records can be stored in {\sf data.frame} objects, as usual. 

\subsection{The {\sf editarray} object}
In the {\sf editrules} package, a set of categorical edits is represented as an {\sf editarray}
object. Formally, we denote an edit array $E$ for $n$ categorical variables and $m$ edits as
(brackets indicate a combination of objects)  
\begin{equation}
    E = \langle {\bf A},{\bf ind}\rangle\textrm{, with }{\bf A}\in\{0,1\}^{m\times d}\textrm{ and }
    d = \sum_{k=1}^n d_k,
    \label{eqEditarray}
\end{equation}
Each row ${\bf a}$ of ${\bf A}$ contains the boolean representation of one edit, and the
$d_k$ denote the number of categories of each variable.  The object {\bf ind}
is a nested {\sf list} which relates columns of {\bf A} to variable names and
categories.  Labeling variables with $k\in1,2,\ldots,n$ and category values
with $i\in 1,2,\ldots,d_k$, we use the following notations:
\begin{eqnarray}
    {\bf ind}(k,i) &=& \sum_{j< k }d_j + i\\
    {\bf ind}(k)   &=& \{{\bf ind}(k,i)\,|\, i\in D_k\}.
\end{eqnarray}
So $\ind(k,i)$ is the column index in {\bf A} for variable $k$ and category $i$
and $\ind(k)$ is the set of column indices corresponding to the categories of
variable $k$.  The {\sf editarray} is the central object for computing with
catgegorical edits, just like the {\sf editmatrix} is the central object for
computations with linear edits.

It is both tedious and error prone to define and maintain an editarray by hand.
In practice, categorical edits are usually stated verbosely, such as: ``a male
subject cannot be pregnant'', or ``an under-aged subject cannot be married''.
To facilitate the definition of edit arrays, {\sf editrules} is equipped with a
parser, which takes R-statements in {\sf character} format, and translates them
to an {\sf editarray}.

%
\begin{Rcode}
<<keep.source=true>>=
E <- editarray(c(
    "gender %in% c('male','female')",
    "pregnant %in% c('yes','no')",
    "if (gender == 'male') pregnant == 'no'"
    )
)
E
datamodel(E)
@
\caption{Defining a simple {\sf editarray} with the {\sf editarray} function.
The array is printed with abbreviated column heads, which themselves consist of
variable names and categories seperated by a colon (by default). When printed
to screen, a {\sf character} version of the edits is shown as well, for
readability.
}
\label{Reditarray}
\end{Rcode}
%
Figure \ref{Reditarray} shows a simple example of defining an editmatrix with
the editrules package.  The first two edits in Figure \ref{Reditarray} define
the data model. The {\sf editarray} function derives the datamodel based on the
variable names and categories it finds in the edits, whether they are
univariate (defining domains) of multivariate. This means that if all possible
variables and categories are mentioned in the multivariate edits, the correct
datamodel will be derived as well. It is important to note that most functions
working on categorical edits assume that the full datamodel is represented
in the columns of an {\sf editarray}. The function {\sf datamodel} accepts an
edit array as input and returns an overview of variables and their categories
for easy inspection.

When printed to the screen, the boolean array is shown with column heads of the form
\begin{quote}
{\sf <variable><separator><category>}, 
\end{quote}
where both variable names and categories are abbreviated for readability, and
the standard separator is a colon ({\sf :}). The separator may not occur as a
symbol in either variable or category name, and its value can be determined by
passing a custom {\sf sep} argument to {\sf editarray}.

Internally, {\sf editarray} uses the {\sf R} internal {\sf parse} function to
transform the {\sf character} expressions to a parse tree, which is
subsequently traversed recursively to derive the entries of the editmatrix. The
opposite is also possible. The {\sf R} internal function {\sf as.character} has
been overloaded to derive a {\sf character} representation from a boolean
representation. When printed to the screen, both the boolean and textual
representation are shown.

The character expressions that can be read by {\sf editarray}, such as
\begin{quote}
\verb+"if ( gender == 'male' ) pregnant = 'no'"+ 
\end{quote}
follows standard {\sf R} syntax, which should be already familliar to the
reader. Note that double quotes are used to enclose the whole string, while
single quotes are used for category names. Table \ref{tabOperators} shows
which operators and functions can be used to specify categorical edit rules.



Categories may be litaral characters, or booleans.  It is worth noting that
expressions on the right hand side of the {\sf \%in\%}  and {\sf ==} operators
are evaluated. One useful application of this is that the categories, or data
model can be defined outside of the edits:
%
<<keep.source=true>>=
xval <- letters[1:4]
yval <- c(TRUE,FALSE)
editarray(c( "x %in% xval","y %in% yval","if ( x %in% c('a','b') ) !y "))
@
%
The above example also illustrates the use of boolean categories.



\begin{table}
\begin{threeparttable}
\caption{Functions and operators that may be used to define edits with {\sf editarray} }
\label{tabOperators}
\begin{tabular}{ll}
\hline
Operator & Description\\
\hline
{\sf \%in\%} & Set membership$^*$  \\
{\sf ==}     & Equality$^*$ \\
{\sf if( <condition> ) <expression> } & conditional statement\\
{\sf c(\verb"'"<cat1>\verb"'",\verb"'"<cat2>\verb"'",...)} & categories, {\sf character} or {\sf logical}\\
{\sf \&\&}    & logical {\sc and}\\
{\sf ||}      & logical {\sc or}\\
{\sf !}       & logical {\sc not}\\
\hline
\end{tabular}
$^*${\small Right-hand side is evaluated.}
\end{threeparttable}
\end{table}
%

\subsection{Coercion, checking, redundancy and infeasibility}
Table \ref{tabBasicfunctions} lists basic functions of {\sf editarray} objects.
The {\sf datamodel} function retrieves the variables and categories in an edit
array, and returns them as a two-column {\sf data.frame}. With {\sf
as.data.frame} or {\sf as.character} one can coerce an editarray so that it can
be written to a file or database. Character coercion is used when edeits are
printed to the screen. Optionally, coercing the datamodel to character form can
be switched off. The result of {\sf as.data.frame} version contains columns
with edit names, a character representaition of the edits and a column for
remarks.

The function {\sf violatedEdits} takes an {\sf editarray} and a {\sf
data.frame} as input and returns a logical matrix indicating which record
(rows) violate which edits (columns). It works by parsing the {\sf editarray}
to R-expressions and evaluating them within the {\sf data.frame} environment.
By default, the records are checked against the data model. This can be turned
off by providing the optional argument {\sf datamodel=FALSE}. 


\begin{table}
\begin{threeparttable}
\caption{Basic functions for objects of class {\sf editarray}. Only mandatory
arguments are shown, refer to the built-in documentation for optional
arguments.}
\label{tabBasicfunctions}
\begin{tabular}{ll}
\hline
Function        & description \\
\hline
{\sf datamodel(E)}           & get datamodel \\
{\sf getVars(E)}             & get a list of variables\\
{\sf as.data.frame(E)}       & coerce edits to {\sf data.frame}\\
{\sf contains(E)}            & which edits contains which variable\\
{\sf as.character(E)}        & coerce edits to {\sf character} vector\\
{\sf violatedEdits(E,x)}     & check which edits are violated by {\sf x}\\
{\sf isObviouslyRedundant(E)}& find redundancies [Eq.\ \eqref{eqRedundancy1}], duplicates\\
{\sf duplicated(E)}          & find duplicate edits\\
{\sf isSubset(E)}            & find edits, subset of another edit [Eq.\ \eqref{eqRedundancy2}]\\
{\sf isObviouslyInfeasible(E)}& detect contradictions\\ 
{\sf substValue(E,var,value)} & substitute a value\\
\hline
\end{tabular}
\end{threeparttable}
\end{table}


When manipulating edit sets, redundant edits of the form in Eq.\ \eqref{eqRedundancy1}
may arise. Such redundancies can be detected in the boolean representation with
{\sf isObviouslyRedundant}. By default, this funciton also checks for duplicate edits,
but this may be turned off. The function {\sf duplicated} is overloaded from the standard
{\sf R} function and the function {\sf isSubset} detects which edits are a subset or
duplicate of another one.

Manipulations may also lead to edits of the form $e=D$, in which case every possible
record is invalid, and the editarray has become impossible to satisfy. The function
{\sf isObviouslyInfeasible} detects whether any such edits are present. They can be 
detected by checking if $\sum_{j=1}^d\rho(e)_j=d$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% SECTION 2
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Manipulation of categorical restrictions}
The basic operations on sets of categorical edits are value substitution and
variable elimination. The former amounts to adapting the datamodel underlying
the edit set while the latter amounts to deriving relations between variables
not involving the eliminated variable. 

In the next subsection we give an example of value subsitution with the {\sf
editrules} package, as well as some background. In subsection
\ref{sscategoryresolution} we describe an elimination method, which appears to
be new to the field of data editing. In subsection \ref{ssequivalence} it is
shown that the method yields results equivalent to Fellegi and Holt's
elimination method while running in polynomial in stead of exponential time.
Finally, in subsection \ref{sseliminateexample} we given an example of
eliminating variables with the {\sf editrules} package. Readers not interested in 
the technical background can skip subsections \ref{sscategoryresolution} and 
\ref{ssequivalence}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Value substitution}
If it is assumed that in a record, one of the variables takes a certain value,
that value may be substituted in the edit rules. In the boolean representation
this amounts to removing all edits which exclude that value, since the record
cannot violate those edits. Secondly, the columns related to the substituted variable,
but not to the substituted category are removed, thus adapting the datamodel to the
new assumption. Algorithm \ref{substValue} gives the pseudocode for reference purposes.
%
\begin{algorithm}[t]
\caption{{\sc substValue($E$,$k$,$v$)}}
\label{substValue}
\begin{algorithmic}
    \Require an {\sf editarray} $E=\langle{\bf A},{\bf ind}\rangle$, a variable index $k$ and a value $v$
    \State $i \leftarrow \ind(k,v)$
    \State ${\bf A}\leftarrow {\bf A}\backslash\{{\bf a}\in\rows({\bf A})\,|\,a_i=\false\}$\Comment{Remove rows not involving $v$ }
    \State ${\bf A} \leftarrow{\bf A}\backslash\{{\bf a}^t_j\in\columns({\bf A})\,|\, j\in\ind(k)\backslash i\}$\Comment{Remove categories $\not=v$}
    \State Update {\bf ind}
    \Ensure $\langle{\bf A},{\bf ind}\rangle$ with $v$ substituted for variable $k$.
\end{algorithmic}
\end{algorithm}
% 

In the {\sf editrules} package, value substitution is performed by the {\sf substValue} function,
which accepts variable and category names. In the following example the editmatrix defined in 
Figure \ref{Reditarray} is used.
<<echo=true>>=
substValue(E,"gender","female")
@
In this case, the variable ``gender'' is substituted by the value ``female''.
With the gender is fixed, the datamodel reduces to
$\{\textrm{male}\}\times\{\textrm{no},\textrm{yes}\}$ and the restriction ``if
male then pregnant = true'' becomes meaningless and is therefore removed.

The {\sf R} implementation of {\sf substValue} has an extra option, allowing to choose
if the datamodel is reduced or not, which by default is set to \true.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Variable elimination by category resolution}
\label{sscategoryresolution}
Given two edits $e$ and $e'$, with boolean representations ${\bf a}$ and
${\bf a}'$ respectively.  We define the {\em resolution operator} $\res_k$ as:
\begin{eqnarray}
\lefteqn{
    {\bf a} \res_k {\bf a}' = {\bf a}_1\land{\bf a}'_1\oplus\ldots\oplus
    {\bf a}_{k-1}\land{\bf a}'_{k-1}}\nonumber\\
&\oplus&    {\bf a}_k\lor{\bf a}'_k\oplus
    {\bf a}_{k+1}\land{\bf a}'_{k+1}\oplus\ldots\oplus
    {\bf a}_n\land{\bf a}'_n
\end{eqnarray}
For two edit sets ${\bf A}$ and ${\bf A'}$, we also introduce the notation
\begin{equation}
{\bf A}\res_k{\bf A}' = \{{\bf a}\res_k{\bf a}'\,|\, ({\bf a},{\bf a}')\in\rows({\bf A})\times\rows({\bf A}')\}.
\end{equation}
%
Observe that the resolution operator has the following properties, relevant for record checking.
\begin{eqnarray}
   \rho({\bf v})\in {\bf a}\res_k{\bf a}' &\Rightarrow& \rho({\bf v})\in{\bf a} \lor \rho({\bf v})\in{\bf a}'\\
   \rho({\bf v})\in {\bf a} &\Rightarrow& \rho({\bf v})\in{\bf a}\res_k{\bf a}' \lor {\bf a}\res_k{\bf a}'=\varnothing
    \label{eqRedundant}
\end{eqnarray}
That is, if a record violates ${\bf a}\res_k{\bf a}'$, it does so because it
violates ${\bf a}$ and/or ${\bf a}'$. Therefore, ${\bf a}\res_k{\bf a}'$ is
also an edit in the sense that a record is invalid if it is falls in the
derived edit.When ${\bf a}_k={\bf a}'_k$, the resulting edit is
the intersection of the original edits, in which case the resulting edit is
redundant.  

The operator is called resolution operator since its action strongly resembles
a resolution operation from formal logic.  If ${\bf a}_k\lor {\bf
a}'_k=(\true)^{d_k}$, the operator ``resolves'' or eliminates the $k^{\rm th}$
variable and we are left with a relation between the other variables,
regardless of the value of variable $k$. The edit resulting from a resolution
operation on two explicitly defined edits is called an {\em implied edit}. If
the resolution operation happens to eliminate one of the variables, it is
called an {\em essential implied edit}. These terms were introduced by
\citet{fellegi:1976} who first solved the problem of error localization for
categorical data. 



The resolution operator can be used to eliminate a variable $k$ from a set of
edits represented by ${\bf A}$ category by category as follows (Algorithm
\ref{eliminate}).  Suppose that $i$ is the column index of the first category
of $k$.  Collect all pairs of $({\bf a}^+,{\bf a}^-)$ obeying $a^+_i=\true$ and
$a^-_i=\false$.  If there are no edits of type ${\bf a}^+$, the variable cannot
be eliminated and the empty set is returned. Otherwise, generate a new set of
edits, consisting of every pair ${\bf a}^+\res_k{\bf a}^-$. By construction,
these new edits all have $a_i=\true$. Possibly, redundant edits have been
produced, and these may be removed. The procedure is iterated for every
category of $k$, adding a category for which each $a_i=\true$ at each
iteration.
%
%
\begin{algorithm}[t]
\caption{{\sc eliminate($E$,$k$)}}
\label{eliminate}
\begin{algorithmic}
    \Require an {\sf editarray} $E=\langle{\bf A},{\bf ind}\rangle$, a variable index $k$
    \For{$i\in \ind(k)$}
    \State ${\bf A}^+ = \{{\bf a}\in{\rm rows}({\bf A})\,:\,a_i=\textrm{\sc true}\}$
    \State ${\bf A}^- = \{{\bf a}\in{\rm rows}({\bf A})\,:\,a_i=\textrm{\sc false}\}$ 
    \If{${\bf A}^+=\varnothing$}
        \State ${\bf A}\leftarrow\varnothing$
        \State {\bf break}
    \EndIf
    \State ${\bf A}\leftarrow {\bf A}^+\res_k {\bf A}^-$
    \State Delete redundant rows from {\bf A}.
    \EndFor
    \Ensure {\sf editarray} $\langle{\bf A},\ind\rangle$ with variable $k$ eliminated
\end{algorithmic}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Equivalence to Fellegi and Holt's elimination method}
\label{ssequivalence}
In this subsection we prove that the function {\sc eliminate} of Algorithm 
\ref{eliminate} is equivalent the elimination method of \cite{fellegi:1976}.
Given a set of $m$ edits:
\begin{equation}
    E = \{ e^{(i)} \in \mathcal{P}(D)\,|\,
    e^{(i)} \textrm{ as in Eq.\ \eqref{eqDefEdit}}
    \textrm{, } 
    i\in 1,2,\ldots,m\}
\label{eqEditSet}
\end{equation}
where $\mathcal{P}(D)$ is the powerset of $D$.  \citet{fellegi:1976}, but also
\cite{waal:2011} define a way to derive new edits, which may be written as a
function $F_k$,
\begin{eqnarray}
\lefteqn{F_k(E) = 
\ocap_{i=1}^m A^{(i)}_1\times
\ocap_{i=1}^m A^{(i)}_2\times\ldots\times
\ocap_{i=1}^m A^{(i)}_{k-1}\times 
}\nonumber\\
&\times& 
\ocup_{i=1}^m A^{(i)}_k\times
\ocap_{i=1}^m A^{(i)}_{k+1}\times
\ldots\times
\ocap_{i=1}^m A^{(i)}_m
\end{eqnarray}
where $k$ is called the {\em generating variable}. In the boolean representation, we have
${\bf A}=\rho(E)$. Using the relations $\rho(e\cap e')=\rho({\bf e})\land\rho({\bf e})$
and $\rho(e\cup e')=\rho(e)\lor\rho(e')$ we may write
\begin{equation}
F_k({\bf A}) = {\bf a}^{(1)}\res_k{\bf a}^{(2)}\res_k,\ldots,\res_k{\bf a}^{(m)}
\quad {\bf a}^{(i)}=\rho\left(e^{(i)}\right),
\label{eqFkBoolRep}
\end{equation}
where we used some obvious properties (symmetry, associativity) of the $\land$
and $\lor$ operators as well.  In fact, substitution in the definition and using
those properties, it can be shown that the resolution operator is symmetric,
associative and idempotent. As a reminder, these properties are defined as
follows.
\begin{equation}
\begin{array}{ll}
\textrm{symmetry:}  &{\bf a}\res_k{\bf b} = {\bf b} \res_k {\bf a} \\
\textrm{associativity:}& ({\bf a}\res_k{\bf b})\res_k {\bf c} = {\bf a}\res_k({\bf b}\res_k {\bf c}).\\
\textrm{idempotency:} &{\bf a}\res_k {\bf a} = {\bf a}.
\end{array}
\end{equation}
%
This following property shows that the resolution operator leaves redundancy relations untouched.
\begin{lemma}
If ${\bf b}\subseteq {\bf c}$\textrm{, then }${\bf a}\res_k {\bf b}\subseteq {\bf a}\res_k {\bf c}$.
\label{lemma}
\end{lemma}
\begin{proof}
We may write ${\bf a} = {\bf a}_k\oplus{\bf a}'$ and similarly for {\bf b} and {\bf c}. This gives
\begin{eqnarray*}
{\bf a}\res_k {\bf b} &=& {\bf a}\res_k ({\bf b}\land {\bf c}) \\
&=& {\bf a}_k\lor ({\bf b}_k\land {\bf c}_k) \oplus {\bf a}'\land ({\bf b}'\land{\bf c}')\\
&=& ({\bf a}_k\land{\bf b}_k)\lor ({\bf a}_k\land{\bf c}_k) \oplus ({\bf a}'\land {\bf b}')\land ({\bf a}'\land{\bf c}')\\
&=& {\bf a}\res_k{\bf b}_k \land {\bf a}\res_k{\bf c} \subseteq {\bf a}\res_j{\bf c},
\end{eqnarray*}
and we are done.
\end{proof}
%
This lemma is important because it shows that removing redundant edits (as shown in Algorithm \ref{eliminate}) 
does not affect the outcome of {\sc eliminate} in the sense that the resulting edit set covers the same subset
of $D$ with or without the redundancy removal step.


We now define more formally the notion of variable elimination.
\begin{definition}
    Given a a function $f:\mathcal{P}(D)\to\mathcal{P}(D)$, and $E\in
    \mathcal{P}(D)$. If none of the edits in $f(E)$ contain variable $k$, we say
    that $f$ eliminates that variable from $E$.
\end{definition}
%
The following theorem establishes equivalence between the function $F_k$ Eq.\
\eqref{eqFkBoolRep} and the resolution operator method of Algorithm
\ref{eliminate}.
\begin{theorem}
Given a set of edits $E$ as in \eqref{eqEditSet} The function $F_k$ eliminates $k$ from $E$, if and
only if {\sc eliminate} eliminates $k$ from $E$.
\end{theorem}

\begin{proof}
First note that $F_k$ does not eliminate $k$ if and only if there is a category
$i$ of $k$ for which $a_i^{(1)}=a_i^{(2)}=\ldots=a_i^{(m)}=\false$.  We call
this property $P$. We will now prove equivalence by showing that {\sc
eliminate} does not eliminate $k$ if and only if $P$. For the if-direction,
suppose that $P$ holds. The order of the for-loop in {\sc eliminate} is
unimportant because $\res_k$ is symmetric and we may therefore assume without
loss of generality that $a_1^{(i)}=\false$ for $i\in1,2,\ldots,m$. {\sc
eliminate} will return $\varnothing$ so all edits in the result contain $k$.
For the reverse statement write ${\bf A}(j)$  for the state of ${\bf A}$ after the $j^{\rm th}$
iteration and similarly for ${\bf A}^+$ and ${\bf A}^-$. Now suppose that {\sc eliminate}
does not eliminate $k$. Then for some $j$, we have ${\bf A}^+(j+1)=\varnothing$,
implying that the $1+j^{\rm th}$ column of ${\bf A}(j+1)$ is \false.
Ignoring the redundancy removal step, we then have
\begin{equation}
{\bf A}^-(j+1) = {\bf A}(j+1) = {\bf A}^+(j)\res_k{\bf A}^-(j)
\end{equation}
This implies that every combination $({\bf a}^+,{\bf a}^-)\in \rows({\bf
A}^+(j))\times\rows({\bf A}^-(j))$ has $a^+_{j+1}=a^+_{j+1}=\false$, showing
that the $1+j^{\rm th}$ column of ${\bf A}(j)$ is \false. By induction, the
matrix ${\bf A}(0)$ must have the $1+j^{\rm th}$ column equal to \false as
well, and we are done.
\end{proof}

\cite{fellegi:1976} use the following scheme to generate all essential implied edits
from a set of explicit edits.
%
\begin{center}
\begin{tabular}{lp{0.9\textwidth}}
\multicolumn{2}{l}{{\bf Procedure} {$\textrm{\sc FH}(E,k)$}}\\
1 &Find all minimal subsets $E_1, E_2,\ldots,E_s$ of $E$, such that $F_k(E_j)$ eliminates $k$ for every $\{j\in 1,2,\ldots,s\}$.
\\
2 &Generate a new set of edits $E=\ocup_{j=1}^sF_k(E_j)$. 
\end{tabular}
\end{center}
%
\subsection{An examples of variable elimination}
\label{sseliminateexample}


\section{Error localization in categorical data}
\label{secErrLocCat}




\bibliographystyle{chicago}
\bibliography{editrules}

\end{document}


%The following distributive property also holds
%\begin{equation}
%\begin{array}{ll}
%\textrm{distributivity:}& ({\bf a}\res_i{\bf b})\res_j{\bf c} = ({\bf a}\res_j{\bf c})\res_i({\bf b}\res_j{\bf c}).
%\end{array}
%\end{equation}

